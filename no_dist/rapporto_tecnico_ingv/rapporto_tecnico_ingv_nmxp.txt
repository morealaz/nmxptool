LIBNMXP: Libreria software Open-SOURCE  PER TRASMISSIONI DATI SISMICI
NANOMETRICS

Matteo Quintiliani

Istituto Nazionale di Geofisica e Vulcanologia

Centro Nazionale Terremoti

e-mail: quintiliani@ingv.it

  TOC \o "1-3" \h \z \u  

Introduzione	  PAGEREF _Toc51836479 \h  5 

1. Protocolli Nanometrics	  PAGEREF _Toc51836480 \h  6 

1.1 Private Data Stream	  PAGEREF _Toc51836481 \h  6 

1.2 Data Access Protocol	  PAGEREF _Toc51836482 \h  7 

2. La libreria libnmxp	  PAGEREF _Toc51836483 \h  8 

2.1 Installazione	  PAGEREF _Toc51836484 \h  8 

2.2 Documentazione	  PAGEREF _Toc51836485 \h  9 

2.3 Uso delle APIs per sviluppare una nuova applicazione	  PAGEREF
_Toc51836486 \h  12 

3. Il programma nmxptool	  PAGEREF _Toc51836487 \h  15 

4. Conclusioni	  PAGEREF _Toc51836488 \h  19 

5. Ringraziamenti	  PAGEREF _Toc51836489 \h  22 

6. Bibliografia e riferimenti web	  PAGEREF _Toc51836490 \h  22 

 

Introduzione

Il presente documento descrive le modalita di impiego della libreria
software progettata dall'autore al fine di implementare i protocolli di
trasmissione Nanometrics. Lo sviluppo di tale libreria nasce
principalmente dall'esigenza all'interno dell'INGV di gestire un numero
sempre pisch crescente di canali sismici acquisiti tramite sistema
Nanometrics. La libreria denominata libnmxp offre un insieme di APIs
(Application Program Interface) ben documentate che permettono di
sviluppare software capace di interagire con i due tipi di server
Nanometrics:

NaqsServer il quale implementa il protocollo per trasmissioni di dati in
tempo reale;

DataServer il quale implementa il protocollo per il recupero di dati
archiviati.

Insieme alla libreria viene inoltre distribuito un programma che si basa
su essa, e di nome nmxptool, che permette di eseguire interrogazioni,
ricevere dati in tempo reale e/o off-line, ed inoltre salvare questi in
diversi formati, quali NMX e mini-SEED. Tale programma put inoltre
essere utilizzato come plug-in per server SeedLink.

L'intero sviluppo si i basato su [Nanometrics, Inc., 1989-2002], in
particolare su Nanometrics Data Formats, Reference Guide inclusa nella
sezione Software Reference Manuals.

La libreria libnmxp e il programma nmxptool sono scritti in linguaggio C
e sviluppati usando i GNU Build Tools (automake, autoconf, e script
configure) tenendo in considerazione gli aspetti di compilazione
trasversale (cross-compilation) su tutte le piattaforme di tipo
POSIX/UNIX. I sorgenti sono gratuiti e possono essere modificati e
ridistribuiti sotto i termini  GNU Library General Public License,
ulteriori informazioni possono essere trovate su http://www.gnu.org/.

Protocolli Nanometrics

Prendendo ad esempio una configurazione tipica del flusso trasmissivo
dei dati da una stazione sismica, passando per i servers Nanometrics,
fino a raggiungere i processi di acquisizione e localizzazione situati
nella Sala di Monitoraggio dell'INGV, come mostrato in figura 1 possiamo
suddividere tale flusso in due parti:

Stazione Sismica - Nanometrics Servers: i dati ricevuti dalla porta
seriale di uno strumento vengono  convertiti nel formato NMXP e poi
spediti in pacchetti UDP ai servers di acquisizione.

Nanometrics Servers - Clients: applicazioni software si connettono ai
servers Nanometrics per recuperare dati in tempo reale o in differita,
ricevere informazioni sullo ``stato di salute'' (state-of-health) degli
strumenti, triggers o eventi sismici.



Figura 1. Configurazione tipica di un flusso trasmissivo dei dati da una
stazione sismica ai processi di acquisizione e localizzazioni situati
nella Sala di Monitoraggio dell'INGV.



Cit di cui terremo conto in questo documento fara riferimento
principalmente al lato trasmissivo Nanometrics Servers - Clients ed in
particolare alle specifiche dei protocolli:

Private Data Stream versione 1.4, il quale definisce il protocollo di
comunicazione di un client con un NaqsServer.

Data Access Protocol versione 1.0, il quale definisce il protocollo di
comunicazione con un DataServer.

La differenza significativa fra i due i che ad un NaqsServer ci si
connette per ricevere dati, informazioni sui canali, triggers e eventi
in tempo reale (online) mentre ad un DataServer per accedere ai dati
alle informazioni del passato (offline).

Di seguito vengono descritti i comportamenti generali di questi due tipi
di servers e dei rispettivi protocolli di trasmissione; per maggiori
dettagli fare riferimento a [Nanometrics, Inc., 1989-2002], in
particolare Nanometrics Data Formats, Reference Guide inclusa nella
sezione Software Reference Manuals.

Private Data Stream 

Il NaqsServer fornisce accesso online via TCP/IP a dati di tipo
time-series, serial data, triggers, e state-of-health.  Il sottosistema
del NaqsServer chiamato Stream Manager si comporta come un DataServer:
accetta connessioni e richieste di dati da programmi client e redirige i
dati richiesti ad ogni programma client in tempo quasi reale. I dati
compressi possono essere richiesti in due modi:

Raw stream: tutti i pacchetti (sia quelli originali quelli ritrasmessi)
sono rediretti nello stesso ordine nel quale sono ricevuti. I pacchetti
possono essere persi, duplicati, non ordinati, ma con con minimo
ritardo.

Buffered stream: anche chiamato Short-term-complete data stream. I
pacchetti per ogni canale sono garantiti essere in ordine cronologico ma
con piccoli ``buchi'' ogni qualvolta si verifichi una ritrasmissione dal
lato trasmissivo Stazione Sismica - Nanometrics Server.

Ogni programma che abbia necessita di interagire con un NaqsServer deve
implementare il protocollo di comunicazione Private Data Stream versione
1.4 cosm come descritto schematicamente di seguito:

Aprire un socket su Stream Manager. La porta di default i la 28000.

Inviare un messaggio di tipo Connect allo Stream Manager.

Ricevere e gestire il messaggio di tipo ChannelList dallo Stream
Manager.

(opzionale) Inviare un messaggio di RequestPending finchy la richiesta
non i pronta. Il server attende al massimo 30 secondi, dopodichy chiude
la connessione se non ha ricevuto ny una Request Pending, ny un
messaggio di AddChannels.

Inviare un messaggio di tipo AddChannels allo Stream Manager.

Ripetere fino alla fine: ricevere i pacchetti dallo Stream Manager ed
elaborarli. Opzionalmente inviare nuovi messaggi AddChannels (passo 5)
oppure RemoveChannels. Il client deve saper gestire i messaggi di tipo
Error.

Inviare un messaggio di tipo TerminateSubscription allo Stream Manager.

Chiudere il socket.

Data Access Protocol

Il DataServer fornisce accesso locale e remoto via TCP/IP a dati di tipo
time-series, serial data, triggers e state-of-health. Il DataServer
fornisce inoltre informazioni sulla disponibilita dei dati di ogni
canale per mezzo di due tipi di liste:

Channel List: una lista dei canali disponibili.

Precis List: una lista dei canali disponibili inclusi i tempi di inizio
e di fine dei dati disponibili per ogni canale.

Ogni programma che abbia necessita di interagire con un DataServer deve
implementare il protocollo di comunicazione Data Access Protocol
versione 1.0 cosm come descritto schematicamente di seguito:

Aprire un socket sul DataServer. La porta di default i la 28002.

Ricevere come intero di 4 byte rappresentante il tempo della
connnessione sul DataServer.

Inviare un messaggio di tipo ConnectRequest includendo il tempo di
connessione ricevuto precedentemente.

Aspettare un messaggio di tipo Ready dal DataServer.

Inviare un messaggio di tipo Request al DataServer.

Ricevere ed elaborare i dati di risposta finchy non si riceve il
messaggio di tipo Ready. Il messaggio Ready indica che il server i
pronto per ricevere nuove richieste.

Ripetere i passi 5 e 6 per ogni richiesta.

(opzionale) Inviare un messaggio di tipo Terminate al DataServer.

Chiudere il socket.

La libreria libnmxp

Dopo aver descritto in generale i protocolli di comunicazione
Nanometrics passiamo ora ad illustrare come la libreria i organizzata e
quali sono le strutture dati e le funzioni che espone per il loro
utilizzo in uno sviluppo di un programma che debba interagire con un
NaqsServer, un DataServer o entrambi.

La libreria i stata scritta in linguaggio C con una strutturazione a
livelli dei sorgenti. In fig. 2 viene mostrata l'organizzazione logica
dei sorgenti.



Figura 2. Organizzazione dei sorgenti della libreria libnmxp.



Le APIs (Application Program Interface) che compongono la libreria
offrono principalmente funzionalita a livello applicativo per lo
sviluppo di software che implementi i protocolli Private Data Stream 1.4
e Data Access Protocol 1.0.

Esse sono state concepite nell'ottica della realizzazione di programmi
in grado di:

manipolare i dati di tipo Nanometrics;

richiedere, ricevere ed interpretare i dati online e offline;

analizzare ed eseguire calcoli in tempo reale sul flusso continuo dei
dati;

recuperare e convertire ``al volo'' i dati in diversi formati, (ad
esempio mini-SEED records);

redirezionare i dati in servers di altro tipo, (ad esempio SeedLink
server).

Al momento la libreria i in grado di trattare i dati di tipo time-series
e non quelli di tipo serial data, triggers e state-of-healt. Per
quest'ultimi si i rimandato lo sviluppo in un futuro prossimo.

Installazione

La libreria libnmxp e il tool nmxptool sono stati sviluppati utilizzando
i GNU Build Tools (automake e autoconf) tenendo conto degli aspetti di
compilazione trasverale (cross-compilation) per tutte le possibili
piattaforme di tipo POSIX/UNIX. Di seguito la tab. 1 mostra su quali
sistemi operativi e architetture si i eseguito con successo
effettivamente il test di funzionamento.

	Little Endian	Big Endian

	Intel 32-bit	Intel 64-bit	SPARC 64bit	PowerPC

Linux	X	X



Solaris	X

X

	Mac OS X	X

	X

FreeBSD	X



	Tabella 1. Sistemi operativi e architetture sui quali libnmxp e
nmxptool sono

                stati installati ed eseguiti con successo.

 

I sorgenti, la documentazione e gli scripts di installazione della
libreria e del programma vengono rilasciati in distribuzioni compresse,
con nome del tipo libnmxp-0.18.0.tar.gz. I requisiti per l'installazione
sono:

Piattaforma POSIX

Compilatore C GNU

Programma make GNU

Il modo pisch semplice per compilare i sorgenti i:

`cd` nella directory che contiene lo script configure

Lanciare il comando ./configure

Se tutto ok lanciare il comando make per la compilazione

Lanciare il comando make install per l'installazione

Quindi, a titolo di esempio, ecco la sequenza dei comandi da eseguire in
una shell per compilare libnmxp e nmxptool contenuti nella distribuzione
libnmxp-0.18.0.tar.gz:

kyuzo:~ mtheo$ tar xvfz libnmxp-0.18.0.tar.gz

kyuzo:~ mtheo$ cd libnmxp-0.18.0

kyuzo:~/libnmxp-0.18.0 mtheo$ ./configure

...

config.status: creating Makefile

config.status: creating src/Makefile

config.status: creating config.h

config.status: executing depfiles commands

configure:

      After running make and make install you will be able

      to compile nmpxtool into the subdirectory tools/nmxptool.

      nmxptool is a tool that implements the following protocols:

                - Nanometrics Data Access Protocol 1.0

                - Nanometrics Private Data Stream  1.4

kyuzo:~/libnmxp-0.18.0 mtheo$ make

kyuzo:~/libnmxp-0.18.0 mtheo$ su root

kyuzo:~/libnmxp-0.18.0 root# make install

kyuzo:~/libnmxp-0.18.0 root# exit

kyuzo:~/libnmxp-0.18.0 mtheo$ cd tools/nmxptool

kyuzo:~/libnmxp-0.18.0/tools/nmxptool mtheo$ ./configure

kyuzo:~/libnmxp-0.18.0/tools/nmxptool mtheo$ make

kyuzo:~/libnmxp-0.18.0/tools/nmxptool mtheo$ su root

kyuzo:~/libnmxp-0.18.0/tools/nmxptool root# make install

kyuzo:~/libnmxp-0.18.0/tools/nmxptool root# exit

Per poter configurare nmxptool come plug-in all'interno di SeisComP sara
sufficiente copiare la directory 135_nmxptool all'interno dei templates
di SeisComP. Supponendo la SeisComP Root uguale a /home/sysop/seiscomp,
ecco un esempio del comando da lanciare:

kyuzo:~/libnmxp-0.18.0/tools/nmxptool mtheo$ cp -r \

seiscomp_templates/135_nmxptool \

/home/sysop/seiscomp/acquisition/templates/source/

Successivamente sara possibile configurare il plug-in per mezzo della
configurazione standard di SeisComP, ovvero lanciando il comando:

kyuzo:~ mtheo$ seiscomp config

Documentazione

La documentazione della libreria i stata redatta in lingua inglese
utilizzando dei meta-tags all'interno del codice e per mezzo del
programma doxygen. Viene rilasciata all'interno del pacchetto di
distribuzione nei formati html, rtf e man. Segue l'elenco e le relative
descrizioni delle sole funzioni, quelle di pisch alto livello, contenute
in nmxp.h. Fare riferimento alla documentazione stessa per maggiori
dettagli.

Documentazione delle APIs di pisch alto livello contenute in nmxp.h

int nmxp_sendConnect (int isock)

Sends the message "Connect" on a socket. 

Parameters:

isock A descriptor referencing the socket.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_sendTerminateSubscription (int isock,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAM%22" NMXP_SHUTDOWN_REASON  reason, char *
message)

Sends the message "TerminateSubscription" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

reason Reason for the shutdown. 

message String message. It could be NULL.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_receiveChannelList (int isock,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAO%22" NMXP_CHAN_LIST  ** pchannelList)

Receive message "NMXP_CHAN_LIST" from a socket. 

Parameters:

isock A descriptor referencing the socket. 

pchannelList List of channels. It will need to be freed!

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_sendAddTimeSeriesChannel (int isock,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAO%22" NMXP_CHAN_LIST  * channelList, int32_t
shortTermCompletion, int32_t out_format,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAH%22" NMXP_BUFFER_FLAG  buffer_flag)

Sends the message "AddTimeSeriesChannels" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

channelList List of channel. 

shortTermCompletion Short-term-completion time = s, 1<= s <= 300
seconds. 

out_format Output format. -1 Compressed packets. 0 Uncompressed packets.
0 < out_format, requested output sample rate. 

buffer_flag Server will send or not buffered packets.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

 HYPERLINK "http://%5Cl%20%22AAAAAAAAAQ%22" NMXP_DATA_PROCESS *
nmxp_receiveData (int isock,  HYPERLINK "http://%5Cl%20%22AAAAAAAAAO%22"
NMXP_CHAN_LIST  * channelList, const char * network_code)

Receive Compressed or Decompressed Data message from a socket and launch
func_processData() on the extracted data. 

Parameters:

isock A descriptor referencing the socket. 

channelList Channel list. 

network_code Network code. It can be NULL.

Return values:

Pointer to the structure  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  on success 

NULL on error 

int nmxp_sendConnectRequest (int isock, char * naqs_username, char *
naqs_password, int32_t connection_time)

Sends the message "ConnectRequest" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

naqs_username User name (maximum 11 characters), zero terminated. 

naqs_password Password. 

connection_time Time that the connection was opened.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_readConnectionTime (int isock, int32_t * connection_time)

Read connection time from a socket. 

Parameters:

isock A descriptor referencing the socket. 

connection_time Time in epoch.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_waitReady (int isock)

Wait the message "Ready" from a socket. 

Parameters:

isock A descriptor referencing the socket.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_sendDataRequest (int isock, int32_t key, int32_t start_time,
int32_t end_time)

Sends the message "DataRequest" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

key Channel key for which data are requested. 

start_time Start time of the interval for which data are requested.
Epoch time. 

end_time End time of the interval for which data are requested. Epoch
time.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

 HYPERLINK "http://%5Cl%20%22AAAAAAAAAO%22" NMXP_CHAN_LIST *
nmxp_getAvailableChannelList (char * hostname, int portnum,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAX%22" NMXP_DATATYPE  datatype)

Get the list of available channels from a server. 

Parameters:

hostname host name 

portnum port number 

datatype Type of data contained in the channel.

Returns:

Channel list. It will need to be freed.

Warning:

Returned value will need to be freed. 

 HYPERLINK "http://%5Cl%20%22AAAAAAAAAY%22" NMXP_META_CHAN_LIST *
nmxp_getMetaChannelList (char * hostname, int portnum,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAX%22" NMXP_DATATYPE  datatype, int
flag_request_channelinfo)

Get the list of the start and end time for the available data for each
channel. 

Parameters:

hostname host name 

portnum port number 

datatype Type of data contained in the channel. 

flag_request_channelinfo Request information about Network.

Returns:

Channel list. It will need to be freed.

Warning:

Returned value will need to be freed. 

int nmxp_raw_stream_seq_no_compare (const void * a, const void * b)

Base function for qsort() in order to sort an array of pointers to
pointers to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS . 

Parameters:

a pointer to a pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  

b pointer to a pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  

void nmxp_raw_stream_init ( HYPERLINK "http://%5Cl%20%22AAAAAAAAAD%22"
NMXP_RAW_STREAM_DATA  * raw_stream_buffer, int32_t max_pdlist_items)

Allocate and initialize fields inside a  HYPERLINK
"http://%5Cl%20%22AAAAAAAABD%22" NMXP_RAW_STREAM_DATA  structure. 

Parameters:

raw_stream_buffer pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  struct to initialize 

max_pdlist_items value of max number of items in array 

void nmxp_raw_stream_free ( HYPERLINK "http://%5Cl%20%22AAAAAAAAAD%22"
NMXP_RAW_STREAM_DATA  * raw_stream_buffer)

Free fields inside a  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  structure. 

Parameters:

raw_stream_buffer pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  struct to initialize 

int nmxp_raw_stream_manage ( HYPERLINK "http://%5Cl%20%22AAAAAAAAAD%22"
NMXP_RAW_STREAM_DATA  * p,  HYPERLINK "http://%5Cl%20%22AAAAAAAAAQ%22"
NMXP_DATA_PROCESS  * a_pd, int(*[])( HYPERLINK
"http://%5Cl%20%22AAAAAAAAAQ%22" NMXP_DATA_PROCESS  *) NMXP_MAX_FUNC_PD,
int n_func_pd)

Execute a list of functions on an chronological ordered array of 
HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22" NMXP_DATA_PROCESS 
structures. 

Parameters:

p pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  

a_pd pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  struct to insert into the array 

p_func_pd array of functions to execute on a single item  HYPERLINK
"http://%5Cl%20%22AAAAAAAABB%22" NMXP_DATA_PROCESS  

n_func_pd number of functions into the array p_func_pd 



Degne di particolare attenzione sono le funzioni che si occupano della
gestione del buffering dei pacchetti nelle connessioni di tipo Raw
Stream, cioi dei pacchetti compressi e con valore di Short-term-complete
uguale a -1. La funzione nmxp_raw_stream_manage() si occupa di ordinare
i pacchetti ricevuti, fino ad un massimo impostato tramite
nmxp_raw_stream_init() al momento dell'inizializzazione del buffer, ed
eseguire con minima latenza possibile le n_func_pd funzioni sulle
strutture di tipo NMXP_DATA_PROCESS. 

Uso delle APIs per sviluppare una nuova applicazione

Per sviluppare una propria applicazione in C che faccia uso della
libreria libnmxp vengono di seguito illustrati i sorgenti 1 e 2 che
possono essere utilizzati come base per l'implementazione dei protocolli
Data Access Protocol 1.0 e Private Data Stream 1.4. Su tali strutture i
basato anche nmxptool descritto successivamente.

Sorgente 1. Struttura base in C che implementa D.A.P. versione 1.0
utilizzando le APIs di libnmxp.

/* ************************************************************** */

/* Start subscription protocol "DATA ACCESS PROTOCOL" version 1.0 */

/* ************************************************************** */

/* DAP Step 1: Open a socket */

if( (naqssock =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#44f981ae9125ff482b93e74a9df45c0c" nmxp_openSocket
(params.hostname, params.portnumberdap)) ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#4e3388111ddab1454d6bd987f1f17435" NMXP_SOCKET_ERROR )
{

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error opening socket!\n");

  return 1;

}

/* DAP Step 2: Read connection time */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#5242ad29c198813884300244dd10179e" nmxp_readConnectionTime
(naqssock, &connection_time) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error reading connection time from server!\n");

  return 1;

}

/* DAP Step 3: Send a ConnectRequest */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#b9ca7e70152dcbddd0f90fafcf764c98" nmxp_sendConnectRequest
(naqssock, params.datas_username, params.datas_password,
connection_time) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error sending connect request!\n");

  return 1;

}

/* DAP Step 4: Wait for a Ready message */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#e05f693ef0012617e25735f412c1f590" nmxp_waitReady (naqssock)
!=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error waiting Ready message!\n");

  return 1;

}

while(exitdapcondition) {

  /* Start loop for sending requests */

  while(request_SOCKET_OK ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK   &&
 i_chan < channelList_subset->number) {

    /* DAP Step 5: Send Data Request */

    request_SOCKET_OK =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#6bf4cb425c1ae31248e19d2e053fbe90" nmxp_sendDataRequest
(naqssock, channelList_subset->channel[i_chan].key,

        (double) params.start_time, (double) params.end_time);

    if(request_SOCKET_OK ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

      /* DAP Step 6: Receive Data until receiving a Ready message */

      ret =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#c4f875c1f2e85f62e4c2521adc897479" nmxp_receiveMessage
(naqssock, &type, &buffer, &length);

       HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (0, 1, "ret
= %d, type = %d\n", ret, type);

      while(ret ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK   
&&    type !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#ac688b3df69e8cf6f2ac256ee5da658bdf9196bb257dcc4c91847
7edc05bd6cb" NMXP_MSG_READY ) {

        /* Process a packet and return value in NMXP_DATA_PROCESS
structure */

        pd =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#8893b6eee3b7c72e999477d8c84da476"
nmxp_processCompressedData (buffer, length, channelList_subset,
CURRENT_NETWORK);

         HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#1a461f85840339c840b377a7f55991a0" nmxp_data_trim (pd,
params.start_time, params.end_time, 0);

        /* Log contents of last packet */

         HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#700d4b5ad54544d0546ffbc0d2aede35" nmxp_data_log (pd);

        if(pd->buffer) {

          free(pd->buffer);

          pd->buffer = NULL;

        }

        /* Receive Data */

        ret =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#c4f875c1f2e85f62e4c2521adc897479" nmxp_receiveMessage
(naqssock, &type, &buffer, &length);

      }

    }

    i_chan++;

  }

  /* DAP Step 7: Repeat steps 5 and 6 for each data request */

} /* END while(exitdapcondition) */

/* DAP Step 8: Send a Terminate message (optional) */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#13d94c3a1d78e315c72d3739331551f9"
nmxp_sendTerminateSubscription (naqssock,  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#2982ac3a4037ee612e56720295987f6df8cb753861ebf3a83e491
cd3d7cd5d69" NMXP_SHUTDOWN_NORMAL , "Bye!");

/* DAP Step 9: Close the socket */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#20009090764c1a6c6d3416275d0dcc89" nmxp_closeSocket
(naqssock);

/* ************************************************************ */

/* End subscription protocol "DATA ACCESS PROTOCOL" version 1.0 */

/* ************************************************************ */



Sorgente 2. Struttura base in C che implementa P.D.S. versione 1.4
utilizzando le APIs di libnmxp.

int n_func_pd = 0;

int (*p_func_pd[ HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#d01d7b80bf5ea8cf7cf6cb6d42d4a19f" NMXP_MAX_FUNC_PD ]) (
HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
struct_n_m_x_p___d_a_t_a___p_r_o_c_e_s_s.html" NMXP_DATA_PROCESS  *);

if(params.stc == -1) {

  if(params.flag_logdata) {

    p_func_pd[n_func_pd++] = nmxptool_print_seq_no;

  }

  /* Write Mini-SEED record */

  if(params.flag_writeseed) {

    p_func_pd[n_func_pd++] = nmxptool_write_miniseed;

  }

  /* Send data to SeedLink Server */

  if(params.flag_slink) {

    p_func_pd[n_func_pd++] = nmxptool_send_raw_depoch;

  }

}

/* ************************************************************* */

/* Start subscription protocol "PRIVATE DATA STREAM" version 1.4 */

/* ************************************************************* */

/* PDS Step 1: Open a socket */

if((naqssock =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#44f981ae9125ff482b93e74a9df45c0c" nmxp_openSocket
(params.hostname, params.portnumberpds)) ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#4e3388111ddab1454d6bd987f1f17435" NMXP_SOCKET_ERROR )
{

  return 1;

}

/* PDS Step 2: Send a Connect */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#8e89c3bd6d36475147d8d14212fdde3f" nmxp_sendConnect
(naqssock) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

  printf("Error on sendConnect()\n");  return 1;

}

/* PDS Step 3: Receive ChannelList */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#404bcdf536d593b187010ae8626234eb" nmxp_receiveChannelList
(naqssock, &channelList) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

  printf("Error on receiveChannelList()\n");  return 1;

}

/* Get a subset of channel from arguments */

channelList_subset =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__chan_8h.html#cd8162e1d1e3a2d07c303567054d5d3d" nmxp_chan_subset
(channelList,  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__chan_8h.html#336bfce71e4b108b0cd469e0e2ddfcf7675e6d98f34fb0ed6a79a
34e49e3d2a2" NMXP_DATA_TIMESERIES , params.channels);

/* PDS Step 4: Send a Request Pending (optional) */

/* PDS Step 5: Send AddChannels */

/* Request Data */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#d56c1e95b99326395adc087ff6437ea0"
nmxp_sendAddTimeSeriesChannel (naqssock, channelList_subset, params.stc,
params.rate,

    (params.flag_buffered)?  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#a01c4a7e4cf68fb71d3c840db57388be8ac1f26351ac3fbe45666febe0c
325d5" NMXP_BUFFER_YES  :  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#a01c4a7e4cf68fb71d3c840db57388be6d79bfe520bb2e4f0278faead3b
97cb5" NMXP_BUFFER_NO );

/* PDS Step 6: Repeat until finished: receive and handle packets */

while(exitpdscondition) {

  /* Process Compressed or Decompressed Data */

  pd =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#c364754b99340141d9dca8eb70352d98" nmxp_receiveData
(naqssock, channelList_subset, CURRENT_NETWORK);

  /* Log contents of last packet */

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#700d4b5ad54544d0546ffbc0d2aede35" nmxp_data_log (pd);

  /* Manage Raw Stream */

  if(params.stc == -1) {

      HYPERLINK "dddd"  nmxp_raw_stream_manage (&(raw_stream_buffer),
pd, p_func_pd, n_func_pd);

  }

  if(pd->buffer) {

    free(pd->buffer);  pd->buffer = NULL;

  }

}

/* PDS Step 7: Send Terminate Subscription */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#13d94c3a1d78e315c72d3739331551f9"
nmxp_sendTerminateSubscription (naqssock,  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#2982ac3a4037ee612e56720295987f6df8cb753861ebf3a83e491
cd3d7cd5d69" NMXP_SHUTDOWN_NORMAL , "Good Bye!");

/* PDS Step 8: Close the socket */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#20009090764c1a6c6d3416275d0dcc89" nmxp_closeSocket
(naqssock);

/* *********************************************************** */

/* End subscription protocol "PRIVATE DATA STREAM" version 1.4 */

/* *********************************************************** */



Il programma nmxptool

Al fine di capire cosa nxmptool permette di fare, lanciamo inizialmente
il comando che stampa a video terminale l'help delle opzioni del
comando:

kyuzo:~ mtheo$ nmxptool -h

nmxptool 0.22.0, Nanometrics tool based on libnmxp-0.22.0

        (Data Access Protocol 1.0, Private Data Stream 1.4)

Usage: nmxptool -H hostname --listchannels [...]

             Receive list of available channels on the host

       nmxptool -H hostname -C channellist -s DATE -e DATE [...]

             Receive data from hostname by DAP

       nmxptool -H hostname -C channellist [...]

             Receive data from hostname by PDS

Arguments:

  -H, --hostname=HOST     Nanometrics hostname.

  -C, --channels=LIST     Channel list STA1.HH?,STA2.??Z,...

Other arguments:

  -P, --portpds=PORT      NaqsServer port number (default 28000).

  -D, --portdap=PORT      DataServer port number (default 28002).

  -N, --network=NET       Declare Network code for all stations (default
'XX').

  -L, --location=LOC      Location code for writing file.

  -v, --verbose           Be verbose.

  -g, --logdata           Print info about data.

  -l, --listchannels      Output list of channel available on
NaqsServer.

  -i, --channelinfo       Output list of channel available on NaqsServer
and channelinfo.

  -m, --writeseed         Pack received data in Mini-SEED records and
write to a file.

  -w, --writefile         Dump received data to a file.

  -k, --slink=plug_name   Send received data to SeedLink like as
plug-in.

                          plug_name is set by SeisComP daemon.

                          THIS OPTION MUST BE THE LAST WITHOUT plug_name
IN seedlink.ini!

  -V, --version           Print tool version.

  -h, --help              Print this help.

DAP Arguments:

  -s, --start_time=DATE   Start time in date format.

  -e, --end_time=DATE     End time in date format.

                          DATE can be in formats:

                              <date>,<time> | <date>

                          where:

                              <date> = yyyy/mm/dd | yyy.jjj

                              <time> = hh:mm:ss | hh:mm

  -d, --delay=SECs        Receive continuosly data with delay
[60..86400].

  -u, --username=USER     DataServer username.

  -p, --password=PASS     DataServer password.

PDS arguments:

  -S, --stc=SECs          Short-term-completion (default -1).

                          -1 is for Raw Stream, no short-term
completion.

                           0 chronological order without waiting for
missing data.

                          [0..300] wait a period for the gap to be
filled by retransmitted packets.

                          Raw Stream is usable only with --rate=-1.

  -R, --rate=Hz           Receive data with specified sample rate
(default -1).

                          -1 is for original sample rate and compressed
data.

                           0 is for original sample rate and
decompressed data.

                          >0 is for specified sample rate and
decompressed data.

  -b, --buffered          Request also recent packets into the past.

  -M, --maxlatency=SECs   Max tollerable latency (default 600)
[60..600].

                          Usable only with Raw Stream --stc=-1.

Matteo Quintiliani - Istituto Nazionale di Geofisica e Vulcanologia -
Italy

Mail bug reports and suggestions to <quintiliani@ingv.it>.



Da tale output deduciamo che un parametro sempre necessario i il nome o
l'IP del server al quale richiedere i dati. Il programma, in funzione
dei parametri passati, determina automaticamente se effettuare una
connessione al NaqsServer (porta 28000) oppure al DataServer (porta
28002). Se le porte dei servers non sono quelle di default i necessario
utilizzare le opzioni -P e -D. Un primo utilizzo di nmxptool per esempio
potrebbe essere quello di impiegarlo per reperire la lista dei canali
disponibili sul server e dei tempo di inizio e fine dei dati per ogni
canale. Cit si ottiene per mezzo del comando:

kyuzo:~ mtheo$ nmxptool -H hostname -l

Una parte di un possibile output:

...

1255538946 USI.HHE.IV      (2007.233,10:39:21.0000  - 
2007.243,09:59:44.0000)

1255538945 USI.HHN.IV      (2007.233,16:20:53.0000  - 
2007.243,09:59:45.0000)

1255538944 USI.HHZ.IV      (2007.233,22:26:08.0000  - 
2007.243,09:59:31.0000)

1238565122 VAGA.HHE.IV     (2007.225,07:10:14.0000  - 
2007.243,09:59:19.0000)

1238565121 VAGA.HHN.IV     (2007.225,08:35:24.0000  - 
2007.243,09:59:29.0000)

1238565120 VAGA.HHZ.IV     (2007.225,00:03:14.0000  - 
2007.243,09:59:29.0000)

...



Per ogni canale disponibile viene visualizzato:

l'indice numerico Nanometrics del canale, denominato key channel

il nome del canale nella forma Station.Channel.Network

data e ora di inizio dei dati disponibili

data e ora di fine dei dati disponibili

Successivamente potremmo richiedere al DataServer i dati appartenenti ad
un certo intervallo di tempo e di un insieme di canali, il comando
allora dovra contenere le opzioni -s, -e, -C,  quindi ad esempio:

kyuzo:~ mtheo$ nmxptool -H hostname -s 2007.242,00:00 -e
2007/08/30,00:00:05 \

                                                      -C
USI.???,VAGA.HHZ -g

Osserviamo che la data put essere scritta seguendo le seguenti regole:

DATA,ORA oppure solamente DATA

dove:

DATA put essere espressa nei seguenti formati:

     aaaa/mm/gg

     aaa.jjj

jjj i il giorno giuliano dell'anno

ORA put essere espressa nei seguenti formati:

    hh:mm:ss

    hh:mm

Se si specifica solo DATA allora l'ora verra

automaticamente impostata a 00:00



Notiamo inoltre che la lista dei canali put contenere il carattere
speciale ? che ha il significato di ``qualsiasi carattere''. Alla riga
di comando abbiamo aggiunto anche l'opzione -g che visualizza
informazioni su ogni pacchetto ricevuto. Ecco un output possibile:

XX.USI.HHE 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.8699) lat
130115.1s [1, 48353370] (0)   87pts (-1128, -1128, 1742, 3226, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:00.8699 - 2007.242,00:00:01.9899) lat
130114.0s [1, 48353371] (0)  112pts (3226, 3226, 2423, 2688, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:01.9900 - 2007.242,00:00:03.1099) lat
130112.9s [1, 48353372] (0)  112pts (2688, 2688, -548, -686, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:03.1099 - 2007.242,00:00:04.2500) lat
130111.8s [1, 48353373] (0)  114pts (-686, -686, -857, -74, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:04.2500 - 2007.242,00:00:05.0000) lat
130111.0s [1, 48353374] (0)   75pts (-74, -74, 1290, 1338, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.2500) lat
130116.8s [1, 49688091] (0)   25pts (301, 301, 11, -143, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:00.2500 - 2007.242,00:00:01.3699) lat
130115.6s [1, 49688092] (0)  112pts (-143, -143, 926, 1534, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:01.3699 - 2007.242,00:00:02.5099) lat
130114.5s [1, 49688093] (0)  114pts (1534, 1534, -220, -17, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:02.5099 - 2007.242,00:00:03.6299) lat
130113.4s [1, 49688094] (0)  112pts (-17, -17, -866, -837, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:03.6300 - 2007.242,00:00:04.7900) lat
130112.2s [1, 49688095] (0)  116pts (-837, -837, -716, -527, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:04.7899 - 2007.242,00:00:05.0000) lat
130112.0s [1, 49688096] (0)   21pts (-527, -527, 999, 790, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.4400) lat
130116.6s [1, 50549101] (0)   44pts (-5470, -5470, -4031, -4326, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:00.4400 - 2007.242,00:00:01.5599) lat
130115.4s [1, 50549102] (0)  112pts (-4326, -4326, -6154, -6408, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:01.5599 - 2007.242,00:00:02.6799) lat
130114.3s [1, 50549103] (0)  112pts (-6408, -6408, -5355, -5326, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:02.6800 - 2007.242,00:00:03.7999) lat
130113.2s [1, 50549104] (0)  112pts (-5326, -5326, -4203, -4963, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:03.7999 - 2007.242,00:00:04.9199) lat
130112.1s [1, 50549105] (0)  112pts (-4963, -4963, -4980, -5066, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:04.9200 - 2007.242,00:00:05.0000) lat
130112.0s [1, 50549106] (0)    8pts (-5066, -5066, -4823, -4804, 1) 276

XX.VAGA.HHZ 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.2999) lat
130116.7s [1, 7848381] (0)   30pts (-10567, -10567, -10553, -10550, 1)
276

XX.VAGA.HHZ 100Hz (2007.242,00:00:00.2999 - 2007.242,00:00:02.5399) lat
130114.5s [1, 7848382] (0)  224pts (-10550, -10550, -10456, -10458, 1)
276

XX.VAGA.HHZ 100Hz (2007.242,00:00:02.5399 - 2007.242,00:00:04.7799) lat
130112.2s [1, 7848383] (0)  224pts (-10458, -10458, -10363, -10362, 1)
276

XX.VAGA.HHZ 100Hz (2007.242,00:00:04.7799 - 2007.242,00:00:05.0000) lat
130112.0s [1, 7848384] (0)   22pts (-10362, -10362, -10331, -10337, 1)
276



Per ogni pacchetto ricevuto viene visualizzato:

il nome del canale nella forma Network.Station.Channel

la frequenza di campionamento

i tempi del primo e dell'ultimo campione

la latenza in secondi rispetto all'ora del client

il tipo del pacchetto Nanometrics e il suo numero di sequenza

il valore del numero di sequenza del pisch vecchio pacchetto disponibile

il numero di campioni presenti nel pacchetto

il valore x0 contenuto nell'intestazione (header) del pacchetto
Nanometrics

il primo e l'ultimo valore della serie di campioni

il valore xn, ovvero il valore calcolato che dovra avere x0 nel
pacchetto successivo

il flag che indica se x0 e xn sono significativi (0 significativo, -1
non significativo)

la lunghezza in bytes del pacchetto Nanometrics ricevuto

Nell'esempio precedente, non essendo stata definita la rete (network),
per default il programma l'ha impostata a `XX'. Nel caso avessimo voluto
salvare i dati in formato mini-SEED sarebbe stato sufficiente aggiungere
l'opzione -m, il programma avrebbe generato un file per ogni canale.
Inoltre, se il DataServer avesse richiesto l'autenticazione si sarebbero
dovute utilizzare le opzioni per la definizione del nome utente e della
password, ovvero -u e -p.

Per avere un flusso di dati continuo ma in differita con uno specifico
tempo stabilito i possibile utilizzare l'opzione -d. In questo modo si
ricevono quindi dati in flusso continuo dal DataServer tenendo fissa la
latenza al valore impostato. Ad esempio, per 10 minuti (600 secondi) di
differita ecco un possibile comando:

kyuzo:~ mtheo$ nmxptool -H hostname -d 600 -C USI.???,VAGA.HHZ -g

Per ricevere dati in tempo reale, ovvero da un NaqsServer, i
sufficiente, in generale, non definire l'intervallo temporale, quindi un
comando del tipo:

kyuzo:~ mtheo$ nmxptool -H hostname -C USI.??? -g -R 100

restituirebbe un output simile a questo di seguito:

XX.USI.HHN 100Hz (2007.243,12:22:48.0000 - 2007.243,12:22:49.0000) lat
9.0s [4, -1] (-1)  100pts (-1, 2080, 2488, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:48.0000 - 2007.243,12:22:49.0000) lat
9.0s [4, -1] (-1)  100pts (-1, 703, 2789, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:49.0000 - 2007.243,12:22:50.0000) lat
8.0s [4, -1] (-1)  100pts (-1, 2947, -1268, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:49.0000 - 2007.243,12:22:50.0000) lat
8.0s [4, -1] (-1)  100pts (-1, 1924, 204, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:49.0000 - 2007.243,12:22:50.0000) lat
8.0s [4, -1] (-1)  100pts (-1, 2490, -1004, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:50.0000 - 2007.243,12:22:51.0000) lat
7.0s [4, -1] (-1)  100pts (-1, -931, 1006, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:50.0000 - 2007.243,12:22:51.0000) lat
7.0s [4, -1] (-1)  100pts (-1, -1131, 1239, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:50.0000 - 2007.243,12:22:51.0000) lat
7.0s [4, -1] (-1)  100pts (-1, -103, -588, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:51.0000 - 2007.243,12:22:52.0000) lat
6.0s [4, -1] (-1)  100pts (-1, 951, 3495, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:51.0000 - 2007.243,12:22:52.0000) lat
6.0s [4, -1] (-1)  100pts (-1, 1318, 790, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:51.0000 - 2007.243,12:22:52.0000) lat
6.0s [4, -1] (-1)  100pts (-1, -467, 93, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:52.0000 - 2007.243,12:22:53.0000) lat
5.0s [4, -1] (-1)  100pts (-1, 365, 956, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:52.0000 - 2007.243,12:22:53.0000) lat
5.0s [4, -1] (-1)  100pts (-1, 3356, 2437, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:52.0000 - 2007.243,12:22:53.0000) lat
5.0s [4, -1] (-1)  100pts (-1, 1034, 1527, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:53.0000 - 2007.243,12:22:54.0000) lat
4.0s [4, -1] (-1)  100pts (-1, 951, 16, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:53.0000 - 2007.243,12:22:54.0000) lat
4.0s [4, -1] (-1)  100pts (-1, 2559, -319, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:53.0000 - 2007.243,12:22:54.0000) lat
4.0s [4, -1] (-1)  100pts (-1, 1472, 675, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:54.0000 - 2007.243,12:22:55.0000) lat
3.0s [4, -1] (-1)  100pts (-1, 255, -351, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:54.0000 - 2007.243,12:22:55.0000) lat
3.0s [4, -1] (-1)  100pts (-1, -668, 1457, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:54.0000 - 2007.243,12:22:55.0000) lat
3.0s [4, -1] (-1)  100pts (-1, 1101, 1541, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:55.0000 - 2007.243,12:22:56.0000) lat
2.0s [4, -1] (-1)  100pts (-1, -540, 1162, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:55.0000 - 2007.243,12:22:56.0000) lat
2.0s [4, -1] (-1)  100pts (-1, 1593, -488, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:55.0000 - 2007.243,12:22:56.0000) lat
2.0s [4, -1] (-1)  100pts (-1, 1608, 1355, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:56.0000 - 2007.243,12:22:57.0000) lat
1.0s [4, -1] (-1)  100pts (-1, 1324, -1674, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:56.0000 - 2007.243,12:22:57.0000) lat
2.0s [4, -1] (-1)  100pts (-1, -371, 2315, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:56.0000 - 2007.243,12:22:57.0000) lat
2.0s [4, -1] (-1)  100pts (-1, 1279, 967, -1, 0) 420



L'opzione -R i stata utilizzata per dichiarare che i pacchetti da
ricevere sarebbe stati scompattati dal server con una frequenza di
100Hz. Notiamo infatti che il pacchetto i di tipo 4, ovvero decompresso,
con una capacita fissa di un secondo e che x0 e xn non sono
significativi. Per i pacchetti compressi (packet type 1) invece avremmo
pouto specificare inoltre, tramite l'opzione -S, un valore fra 1 e 300
secondi dello Short-term-complete, oppure 0 per nessun
Short-term-complete,  oppure uguale -1 per ricevere i pacchetti in
modalita Raw Stream. 

Quest'ultimo caso rappresenta una delle funzionalita pisch importanti di
nmxptool poichy consente di ricevere i pacchetti in modo continuo in
tempo reale, in ordine cronologico, con minima latenza e minimo numero
di gaps.  Il programma  i in grado di gestire il buffering dei pacchetti
trasmessi e ritrasmessi, il loro riordinamento e l'esecuzione delle
operazione selezionate tramite le opzioni. Un'opzione collegata a questa
gestione i -M che serve a specificare la massima latenza tollerabile
nell'attesa di un pacchetto mancante, da tale opzione dipende di
conseguenza la grandezza del buffer.

Quando si interagisce con il NaqsServer si put anche utilizzare
l'opzione -b, la quale permette di ricevere anche alcuni dati, in
quantita discrezionale del server, che precedono quelli dell'istante
attuale di richiesta.

Infine, non certo per ordine di importanza, facciamo notare che con
qualsiasi configurazione di opzioni descritte precedentemente, nmxptool
put essere lanciato come un plug-in per SeedLink per mezzo dell'utilizzo
dell'opzione -k. Questa opzione deve essere necessariamente dichiarata
per ultima. All'interno della distribuzione sono inoltre disponibili i
templates SeedLink necessari alla configurazione del plug-in per mezzo
del comando ``seiscomp config''. E' comunque in corso la richiesta per
inserire nmxptool fra i plug-ins delle distribuzioni ufficiali di
SeisComP.

La figura 3 illustra come nmxptool viene utilizzato all'interno
dell'INGV per archiviare i dati sismici delle stazioni che trasmettono
tramite i protocolli Nanometrics. Le forme d'onda vengono ricevute in
tempo reale in modalita Raw Stream al fine di minimizzare la latenza e
il numero di gaps. nmxptool viene configurato e lanciato all'interno del
sistema SeisComp come plug-in per SeedLink. La latenza indotta dal
programma, non quella causata dal mezzo trasmissivo ad esempio, i
determinata solo nel caso in cui si rimanga in attesa di uno o pisch
pacchetti mancanti. Tale attesa termina nel momento in cui il buffer
risulti completamente pieno comportando quindi una perdita di dati
(gap).

Al fine di garantire completezza dei dati archiviati i stata sviluppata
una procedura dal nome ``Nanometrics Data Completness'' che basandosi
sulla versatilita di nmxptool recupera i dati mancanti con differita
impostata a qualche ora o giorno successivo. In questo caso i gaps
risultanti non potranno pisch essere colmati poichy i dati richiesti non
risultano definitivamente pisch essere presenti sul lato dei servers
Nanometrics.



Figura 3. Archiviazione dati sismici in tempo reale e completamento in
differita. Le due attivita si basano con modalita diverse su nmxptool.
Nel primo caso, nmxptool viene utilizzato come plug-in seedLink in
modalita Raw Stream, nel secondo i dati mancanti vengono richiesti da
nmxptool al DataServer e per mezzo dell'applicazione qmerge ricongiunti
alla struttura di archiviazione SDS di SeisComP.



Conclusioni

Lo sviluppo ed i test eseguiti in questi ultimi due mesi hanno permesso
di realizzare una libreria nel suo complesso stabile ed efficiente.
Considerando congiuntamente libnmxp e nmxptool, anche il numero di
funzionalita implementate risulta essere molto soddisfacente, la pisch
importante fra tutte: la gestione delle connessioni di tipo Raw Stream
la quale riesce a garantire una bassa latenza e nel contempo un numero
minino di gaps. Grazie a questa caratteristica nmxptool apporta
finalmente un fondamentale contributo alla comunita degli utilizzatori
del sistema SeisComp, infatti naqs_plugin, il plug-in precedentemente
sviluppato per l'acquisizione da servers Nanometrics, non essendo in
grado di gestire ne' connessioni Short-term-complete ne' i pacchetti
compressi, non poteva garantire minimamente la continuita del dato al
verificarsi di una ritrasmissione dal lato Nanometrics Server - Stazione
Sismica (fig. 1).

Le tabelle 2 e 3 mostrano i reports sintetici dei dati archiviati per i
canali sismici in test il 18 e il 19 settembre 2007. Giornalmente, per
ogni canale viene visualizzato il totale di pacchetti ritrasmessi, la
massima latenza registrata, il numero di gaps temporali ottenuti tramite
l'acquisizione in tempo reale, il numero di gaps definitivi ottenuti
recuperando i dati il giorno dopo e la differenza fra questi due valori
dei gaps. Quest'ultimo valore, rapportato alla latenza massima
risultante, put essere espressione della bonta della gestione del buffer
e della sua dimensione. Possiamo notare inoltre come il numero di gaps
otttenuti in tempo reale dipenda fortemente dal numero di pacchetti
ritrasmessi. La latenza massima tollerabile i indotta dalla grandezza
del buffer la quale i stata impostata per il test a 100 pacchetti.

Al momento nmxptool viene utilizzato come plug-in seedlink anche nei
seguenti istituti di ricerca i quali sono stati inoltre di enorme aiuto
in fase di test e debugging del software:

National Data Center, Israele. (Guy Tikochinsky)

Institute of Geodynamics, National Observatory of Athens, Grecia. (Nicos
Melis)

Inoltre, la procedura sviluppata per garantire la completezza del dato,
basata su nmxptool e qmerge, consente di  avere un controllo di qualita
maggiore sui dati archiviati

Tool a supporto di procedure che necessita di dati a richiesta (ad
esempio dopo un evento sismico)

TODO. Buchi determinati da erronei valori temporali contenuti nei
pacchetti. Priorita del numero di sequenza e del controllo su x0
rispetto al tempo del pacchetto.



Canale	Pacchetti Ritrasmessi	Latenza Massima (sec.)	Gaps

Tempo reale	Gaps

definitivi	Differenza Gaps

CARO.HHN

MRGE.HHN

SALO.HHN

SALO.HHE

SCTE.HHE

DOI.HHN

MRGE.HHZ

AMUR.HHN

AMUR.HHZ

SCTE.HHZ

MRGE.HHE

MABI.HHE

USI.HHN

BOB.HHN

BOB.HHE

BOB.HHZ

USI.HHE

TIR.HHZ

TIR.HHE

TIR.HHN

SCTE.HHN

AMUR.HHE

MABI.HHZ

MDI.HHE

MDI.HHZ

SALO.HHZ

DOI.HHZ

DOI.HHE

CARO.HHE

USI.HHZ

MABI.HHN

MDI.HHN

CARO.HHZ

MSAG.HHE

MSAG.HHZ

MSAG.HHN

SGRT.HHZ

SGRT.HHE

SGRT.HHN

NOCI.HHE

NOCI.HHN

NOCI.HHZ	2

9

18

17

10

8

7

8

7

10

9

14

16

21

24

22

14

17

18

28

9

9

18

5

10

13

16

8

10

20

21

14

7

35

30

33

78

61

77

2038

2117

2096	14.5

17.5

19.4

20.6

36.7

46.3

46.6

47.1

47.8

48.4

48.9

57.0

58.7

58.8

59.8

59.8

68.0

78.0

78.3

78.7

46.6

47.3

177.2

199.8

220.1

225.3

227.1

228.3

232.2

116.3

129.0

219.3

232.5

173.3

232.1

201.4

253.4

237.5

224.9

410.1

387.9

378.7	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

1

1

1

1

1

1

1

1

1

2

2

2

2

4

8

10

17

19

25

222

228

235	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

1

1

1

1

1

1

1

1

1

2

2

2

2

4

8

10

17

19

25

222

228

235

Tabella 2. Report sintetico relativo ai canali in test dei dati
archiviati il 18 settembre 2007 tramite nmxptool e seedllink.





Canale	Pacchetti Ritrasmessi	Latenza Massima (sec.)	Gaps

Tempo reale	Gaps

definitivi	Differenza Gaps

NOCI.HHE

NOCI.HHZ

NOCI.HHN

AMUR.HHE

AMUR.HHN

SALO.HHN

SALO.HHZ

SALO.HHE

DOI.HHZ

MABI.HHZ

DOI.HHN

DOI.HHE

SCTE.HHE

MABI.HHN

SCTE.HHZ

MABI.HHE

MDI.HHZ

SCTE.HHN

AMUR.HHZ

SGRT.HHE

MRGE.HHZ

MRGE.HHE

MRGE.HHN

USI.HHZ

USI.HHN

SGRT.HHN

SGRT.HHZ

USI.HHE

TIR.HHZ

TIR.HHE

MDI.HHN

MDI.HHE

BOB.HHE

BOB.HHZ

TIR.HHN

BOB.HHN

CARO.HHN

CARO.HHZ

CARO.HHE

MSAG.HHZ

MSAG.HHN

MSAG.HHE	7

7

3

9

10

16

8

10

10

4

5

5

6

7

8

13

8

10

9

32

11

13

14

22

18

33

33

17

11

16

8

9

103

84

22

89

819

763

868

253

284

313	27.2

27.3

27.5

37.5

38.0

39.5

39.6

40.8

46.1

46.4

46.5

46.8

46.9

47.0

47.0

47.5

47.5

47.5

48.9

49.3

57.6

57.7

58.2

58.9

59.0

61.9

62.6

67.8

68.9

69.0

192.8

212.5

252.3

262.2

121.0

262.8

233.2

1093.3

1042.8

496.4

475.4

463.9	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

1

1

3

3

2

4

4

4

7

30

35

37	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

2

2

0

2

0

0

0

0

0

0	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

1

1

1

1

2

2

4

4

7

30

35

37

Tabella 3. Report sintetico relativo ai canali in test dei dati
archiviati il 19 settembre 2007 tramite nmxptool e seedllink.



Ringraziamenti

Un particolare ringraziamento va a Salvatore Mazza per la fiducia che
sempre mi riserva. Sono inoltre riconoscente a Marco Olivieri per il suo
supporto nel controllo di qualita dei dati prodotti dalle mie
applicazioni.

Bibliografia e riferimenti web

Nanometrics, Inc., (1989-2002), Libra Satellite Seismograph System -
Training Course Notes.

SeisComP, The Seismological Communication Processor

http://www.gfz-potsdam.de/geofon/seiscomp/

Qlib2, qmerge, Quanterra User Group

http://www.ncedc.org/qug/software/ucb/

libmseed, 2.1.4, The Mini-SEED library

http://www.iris.edu/manuals/

Doxygen, Source code documentation generator tool

			http://www.stack.nl/~dimitri/doxygen/

GNU General Public License

			http://www.gnu.org/copyleft/gpl.html

 PAGE   

 PAGE   15 

