LIBNMXP E NMXPTOOL: software Open-SOURCE  PER TRASMISSIONI DATI SISMICI
NANOMETRICS

Matteo Quintiliani

Istituto Nazionale di Geofisica e Vulcanologia

Centro Nazionale Terremoti

e-mail: quintiliani@ingv.it

  TOC \o "1-3" \h \z \u  

Introduzione	  PAGEREF _Toc52248998 \h  5 

1. Protocolli Nanometrics	  PAGEREF _Toc52248999 \h  6 

1.1 Private Data Stream	  PAGEREF _Toc52249000 \h  6 

1.2 Data Access Protocol	  PAGEREF _Toc52249001 \h  7 

2. La libreria libnmxp	  PAGEREF _Toc52249002 \h  8 

2.1 Installazione	  PAGEREF _Toc52249003 \h  8 

2.2 Documentazione	  PAGEREF _Toc52249004 \h  9 

2.3 Uso delle APIs per sviluppare una nuova applicazione	  PAGEREF
_Toc52249007 \h  14 

3. Il programma nmxptool	  PAGEREF _Toc52249008 \h  17 

3.1 Plug-in SeedLink	  PAGEREF _Toc52249009 \h  20 

3.2 Completezza del dato Nanometrics	  PAGEREF _Toc52249010 \h  20 

4. Conclusioni	  PAGEREF _Toc52249011 \h  22 

5. Ringraziamenti	  PAGEREF _Toc52249012 \h  25 

6. Bibliografia e riferimenti web	  PAGEREF _Toc52249013 \h  25 

 

Introduzione

Il presente documento descrive le modalita di impiego della libreria
software progettata dall'autore al fine di implementare i protocolli di
trasmissione Nanometrics. Lo sviluppo di tale libreria nasce
principalmente dall'esigenza all'interno dell'INGV di gestire un numero
sempre pisch crescente di canali sismici acquisiti tramite sistema
Nanometrics. La libreria denominata libnmxp offre un insieme di APIs
(Application Program Interface) ben documentate che permettono di
sviluppare software capace di interagire con i due tipi di server
Nanometrics:

NaqsServer il quale implementa il protocollo per trasmissioni di dati in
tempo reale;

DataServer il quale implementa il protocollo per il recupero di dati
archiviati.

Insieme alla libreria viene inoltre distribuito un programma chiamato
nmxptool che basandosi su di essa permette di eseguire interrogazioni,
ricevere dati in tempo reale e/o off-line, ed inoltre salvare questi in
diversi formati, quali NMX e mini-SEED. Tale programma put inoltre
essere utilizzato come plug-in per server SeedLink.

L'intero sviluppo si i basato su [Nanometrics, Inc., 1989-2002], in
particolare su Nanometrics Data Formats, Reference Guide inclusa nella
sezione Software Reference Manuals.

La libreria libnmxp e il programma nmxptool sono scritti in linguaggio C
e sviluppati usando i GNU Build Tools (automake, autoconf, e script
configure) tenendo in considerazione gli aspetti di compilazione
trasversale (cross-compilation) su tutte le piattaforme di tipo
POSIX/UNIX. I sorgenti sono gratuiti e possono essere modificati e
ridistribuiti sotto i termini  GNU Library General Public License,
ulteriori informazioni possono essere trovate su http://www.gnu.org/.

Protocolli Nanometrics

Prendendo ad esempio una configurazione tipica del flusso trasmissivo
dei dati da una stazione sismica, passando per i servers Nanometrics,
fino a raggiungere i processi di acquisizione e localizzazione situati
nella Sala di Monitoraggio dell'INGV, come mostrato in figura 1 possiamo
suddividere tale flusso in due parti:

Stazione Sismica - Nanometrics Servers: i dati ricevuti dalla porta
seriale di uno strumento vengono  convertiti nel formato NMXP e poi
spediti in pacchetti UDP ai servers di acquisizione.

Nanometrics Servers - Clients: applicazioni software si connettono ai
servers Nanometrics per recuperare dati in tempo reale o in differita,
ricevere informazioni sullo ``stato di salute'' (state-of-health) degli
strumenti, triggers o eventi sismici.



Figura 1. Configurazione tipica di un flusso trasmissivo dei dati da una
stazione sismica ai processi di acquisizione e localizzazioni situati
nella Sala di Monitoraggio dell'INGV.



Cit di cui terremo conto in questo documento fara riferimento
principalmente al lato trasmissivo Nanometrics Servers - Clients ed in
particolare alle specifiche dei protocolli:

Private Data Stream versione 1.4, il quale definisce il protocollo di
comunicazione di un client con un NaqsServer.

Data Access Protocol versione 1.0, il quale definisce il protocollo di
comunicazione con un DataServer.

La differenza significativa fra i due i che ad un NaqsServer ci si
connette per ricevere dati, informazioni sui canali, triggers e eventi
in tempo reale (online) mentre ad un DataServer per accedere ai dati
alle informazioni del passato (offline).

Di seguito vengono descritti i comportamenti generali di questi due tipi
di servers e dei rispettivi protocolli di trasmissione; per maggiori
dettagli fare riferimento a [Nanometrics, Inc., 1989-2002], in
particolare Nanometrics Data Formats, Reference Guide inclusa nella
sezione Software Reference Manuals.

Private Data Stream 

Il NaqsServer fornisce accesso online via TCP/IP a dati di tipo
time-series, serial data, triggers, e state-of-health.  Il sottosistema
del NaqsServer chiamato Stream Manager si comporta come un DataServer:
accetta connessioni e richieste di dati da programmi client e redirige i
dati richiesti ad ogni programma client in tempo quasi reale. I dati
compressi possono essere richiesti in due modi:

Raw stream: tutti i pacchetti (sia quelli originali quelli ritrasmessi)
sono rediretti nello stesso ordine nel quale sono ricevuti. I pacchetti
possono essere persi, duplicati, non ordinati, ma con minimo ritardo.

Buffered stream: anche chiamato Short-term-complete data stream. I
pacchetti per ogni canale sono garantiti essere in ordine cronologico ma
con piccoli ``buchi'' ogni qualvolta si verifichi una ritrasmissione dal
lato trasmissivo Stazione Sismica - Nanometrics Server.

Ogni programma che abbia necessita di interagire con un NaqsServer deve
implementare il protocollo di comunicazione Private Data Stream versione
1.4 cosm come descritto schematicamente di seguito:

Aprire un socket su Stream Manager. La porta di default i la 28000.

Inviare un messaggio di tipo Connect allo Stream Manager.

Ricevere e gestire il messaggio di tipo ChannelList dallo Stream
Manager.

(opzionale) Inviare un messaggio di RequestPending finchy la richiesta
non i pronta. Il server attende al massimo 30 secondi, dopodichy chiude
la connessione se non ha ricevuto ny una Request Pending, ny un
messaggio di AddChannels.

Inviare un messaggio di tipo AddChannels allo Stream Manager.

Ripetere fino alla fine: ricevere i pacchetti dallo Stream Manager ed
elaborarli. Opzionalmente inviare nuovi messaggi AddChannels (passo 5)
oppure RemoveChannels. Il client deve saper gestire i messaggi di tipo
Error.

Inviare un messaggio di tipo TerminateSubscription allo Stream Manager.

Chiudere il socket.

Data Access Protocol

Il DataServer fornisce accesso locale e remoto via TCP/IP a dati di tipo
time-series, serial data, triggers e state-of-health. Il DataServer
fornisce inoltre informazioni sulla disponibilita dei dati di ogni
canale per mezzo di due tipi di liste:

Channel List: una lista dei canali disponibili.

Precis List: una lista dei canali disponibili inclusi i tempi di inizio
e di fine dei dati disponibili per ogni canale.

Ogni programma che abbia necessita di interagire con un DataServer deve
implementare il protocollo di comunicazione Data Access Protocol
versione 1.0 cosm come descritto schematicamente di seguito:

Aprire un socket sul DataServer. La porta di default i la 28002.

Ricevere come intero di 4 byte rappresentante il tempo della
connnessione sul DataServer.

Inviare un messaggio di tipo ConnectRequest includendo il tempo di
connessione ricevuto precedentemente.

Aspettare un messaggio di tipo Ready dal DataServer.

Inviare un messaggio di tipo Request al DataServer.

Ricevere ed elaborare i dati di risposta finchy non si riceve il
messaggio di tipo Ready. Il messaggio Ready indica che il server i
pronto per ricevere nuove richieste.

Ripetere i passi 5 e 6 per ogni richiesta.

(opzionale) Inviare un messaggio di tipo Terminate al DataServer.

Chiudere il socket.

La libreria libnmxp

Dopo aver descritto in generale i protocolli di comunicazione
Nanometrics passiamo ora ad illustrare come la libreria i organizzata e
quali sono le strutture dati e le funzioni che espone per il loro
utilizzo nello sviluppo di un programma che debba interagire con un
NaqsServer, un DataServer o entrambi.

La libreria i stata scritta in linguaggio C con una strutturazione a
livelli dei sorgenti. In fig. 2 viene mostrata l'organizzazione logica
dei sorgenti.



Figura 2. Organizzazione dei sorgenti della libreria libnmxp.



Le APIs (Application Program Interface) che compongono la libreria
offrono principalmente funzionalita a livello applicativo per lo
sviluppo di software che implementi i protocolli Private Data Stream 1.4
e Data Access Protocol 1.0.

Esse sono state concepite nell'ottica della realizzazione di programmi
in grado di:

manipolare i dati di tipo Nanometrics;

richiedere, ricevere ed interpretare i dati online e offline;

analizzare ed eseguire calcoli in tempo reale sul flusso continuo dei
dati;

recuperare e convertire ``al volo'' i dati in diversi formati, (ad
esempio mini-SEED records);

redirezionare i dati in servers di altro tipo, (ad esempio SeedLink
server).

Al momento la libreria i in grado di trattare i dati di tipo time-series
e non quelli di tipo serial data, triggers e state-of-healt. Per
quest'ultimi si i rimandato lo sviluppo in un futuro prossimo.

Installazione

La libreria libnmxp e il tool nmxptool sono stati sviluppati utilizzando
i GNU Build Tools (automake e autoconf) tenendo conto degli aspetti di
compilazione trasverale (cross-compilation) per tutte le possibili
piattaforme di tipo POSIX/UNIX. Di seguito la tabella 1 mostra su quali
sistemi operativi e architetture si i eseguito il test di funzionamento,
la `X' determina che il test ha avuto esito positivo.

	Little Endian	Big Endian

	Intel 32-bit	Intel 64-bit	SPARC 64bit	PowerPC

Linux	X	X



Solaris	X

X

	Mac OS X	X

	X

FreeBSD	X



	Tabella 1. Sistemi operativi e architetture sui quali libnmxp e
nmxptool sono

                stati installati ed eseguiti con successo.

 

I sorgenti, la documentazione e gli scripts di installazione della
libreria e del programma vengono rilasciati in distribuzioni compresse,
con nome del tipo libnmxp-0.22.0.tar.gz. I requisiti per l'installazione
sono:

Piattaforma POSIX

Compilatore C GNU

Programma make GNU

Il modo pisch semplice per compilare i sorgenti i:

`cd` nella directory che contiene lo script configure

Lanciare il comando ./configure

Se tutto ok lanciare il comando make per la compilazione

Lanciare il comando make install per l'installazione

Quindi, a titolo di esempio, ecco la sequenza dei comandi da eseguire in
una shell per compilare libnmxp e nmxptool contenuti nella distribuzione
libnmxp-0.22.0.tar.gz:

kyuzo:~ mtheo$ tar xvfz libnmxp-0.22.0.tar.gz

kyuzo:~ mtheo$ cd libnmxp-0.22.0

kyuzo:~/libnmxp-0.22.0 mtheo$ ./configure

...

config.status: creating Makefile

config.status: creating src/Makefile

config.status: creating config.h

config.status: executing depfiles commands

configure:

      After running make and make install you will be able

      to compile nmpxtool into the subdirectory tools/nmxptool.

      nmxptool is a tool that implements the following protocols:

                - Nanometrics Data Access Protocol 1.0

                - Nanometrics Private Data Stream  1.4

kyuzo:~/libnmxp-0.22.0 mtheo$ make

kyuzo:~/libnmxp-0.22.0 mtheo$ su root

kyuzo:~/libnmxp-0.22.0 root# make install

kyuzo:~/libnmxp-0.22.0 root# exit

kyuzo:~/libnmxp-0.22.0 mtheo$ cd tools/nmxptool

kyuzo:~/libnmxp-0.22.0/tools/nmxptool mtheo$ ./configure

kyuzo:~/libnmxp-0.22.0/tools/nmxptool mtheo$ make

kyuzo:~/libnmxp-0.22.0/tools/nmxptool mtheo$ su root

kyuzo:~/libnmxp-0.22.0/tools/nmxptool root# make install

kyuzo:~/libnmxp-0.22.0/tools/nmxptool root# exit

Per poter configurare nmxptool come plug-in all'interno di SeisComP sara
sufficiente copiare la directory 135_nmxptool all'interno dei templates
di SeisComP. Supponendo la SeisComP Root uguale a /home/sysop/seiscomp,
ecco un esempio del comando da lanciare:

kyuzo:~/libnmxp-0.22.0/tools/nmxptool mtheo$ cp -r \

seiscomp_templates/135_nmxptool \

/home/sysop/seiscomp/acquisition/templates/source/

Successivamente sara possibile configurare il plug-in per mezzo della
configurazione standard di SeisComP, ovvero lanciando il comando:

kyuzo:~ mtheo$ seiscomp config

Documentazione

La documentazione della libreria i stata redatta in lingua inglese
utilizzando dei meta-tags all'interno del codice e per mezzo del
programma doxygen. Viene rilasciata all'interno del pacchetto di
distribuzione nei formati html, rtf e man. Segue l'elenco e le relative
descrizioni delle sole funzioni, quelle di pisch alto livello, contenute
in nmxp.h. Per maggiori dettagli si faccia riferimento alla
documentazione stessa.

Documentazione della struttura dati NMXP_DATA_PROCESS per lo sviluppo
con libnmxp.

NMXP_DATA_PROCESS Struct Reference

 TC  \l 2 "NMXP_DATA_PROCESS"  XE "NMXP_DATA_PROCESS" Parameter
structure for functions that process data. 

 #include <nmxp_data.h>

Public Attributes

int32_t   HYPERLINK  \l "AAAAAAAAHF"  key 

Channel Key. 

char   HYPERLINK  \l "AAAAAAAAHG"  network  [NETWORK_LENGTH]

Network code. 

char   HYPERLINK  \l "AAAAAAAAHH"  station  [STATION_LENGTH]

Station code. 

char   HYPERLINK  \l "AAAAAAAAHI"  channel  [CHANNEL_LENGTH]

Channel code. 

int32_t   HYPERLINK  \l "AAAAAAAAHJ"  packet_type 

Packet type. 

int32_t   HYPERLINK  \l "AAAAAAAAHK"  x0 

First sample. It is significant only if x0n_significant != 0. 

int32_t   HYPERLINK  \l "AAAAAAAAHL"  xn 

Last sample. It is significant only if x0n_significant != 0. 

int32_t   HYPERLINK  \l "AAAAAAAAHM"  x0n_significant 

Declare if xn significant. 

int32_t   HYPERLINK  \l "AAAAAAAAHN"  oldest_seq_no 

Oldest Sequence number. 

int32_t   HYPERLINK  \l "AAAAAAAAHO"  seq_no 

Sequence number. 

double   HYPERLINK  \l "AAAAAAAAHP"  time 

Time first sample. Epochs. 

void *   HYPERLINK  \l "AAAAAAAAHQ"  buffer 

Nanometrics packet data. 

int32_t   HYPERLINK  \l "AAAAAAAAHR"  length 

Packet length. 

int *   HYPERLINK  \l "AAAAAAAAHS"  pDataPtr 

Array of samples. 

int32_t   HYPERLINK  \l "AAAAAAAAHT"  nSamp 

Number or samples. 

int32_t   HYPERLINK  \l "AAAAAAAAHU"  sampRate 

Sample rate.



Documentazione delle APIs di pisch alto livello contenute in nmxp.h

int nmxp_sendConnect (int isock)

Sends the message "Connect" on a socket. 

Parameters:

isock A descriptor referencing the socket.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_sendTerminateSubscription (int isock,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAM%22" NMXP_SHUTDOWN_REASON  reason, char *
message)

Sends the message "TerminateSubscription" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

reason Reason for the shutdown. 

message String message. It could be NULL.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_receiveChannelList (int isock,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAO%22" NMXP_CHAN_LIST  ** pchannelList)

Receive message "NMXP_CHAN_LIST" from a socket. 

Parameters:

isock A descriptor referencing the socket. 

pchannelList List of channels. It will need to be freed!

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_sendAddTimeSeriesChannel (int isock,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAO%22" NMXP_CHAN_LIST  * channelList, int32_t
shortTermCompletion, int32_t out_format,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAH%22" NMXP_BUFFER_FLAG  buffer_flag)

Sends the message "AddTimeSeriesChannels" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

channelList List of channel. 

shortTermCompletion Short-term-completion time = s, 1<= s <= 300
seconds. 

out_format Output format. -1 Compressed packets. 0 Uncompressed packets.
0 < out_format, requested output sample rate. 

buffer_flag Server will send or not buffered packets.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

 HYPERLINK "http://%5Cl%20%22AAAAAAAAAQ%22" NMXP_DATA_PROCESS *
nmxp_receiveData (int isock,  HYPERLINK "http://%5Cl%20%22AAAAAAAAAO%22"
NMXP_CHAN_LIST  * channelList, const char * network_code)

Receive Compressed or Decompressed Data message from a socket and launch
func_processData() on the extracted data. 

Parameters:

isock A descriptor referencing the socket. 

channelList Channel list. 

network_code Network code. It can be NULL.

Return values:

Pointer to the structure  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  on success 

NULL on error 

int nmxp_sendConnectRequest (int isock, char * naqs_username, char *
naqs_password, int32_t connection_time)

Sends the message "ConnectRequest" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

naqs_username User name (maximum 11 characters), zero terminated. 

naqs_password Password. 

connection_time Time that the connection was opened.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_readConnectionTime (int isock, int32_t * connection_time)

Read connection time from a socket. 

Parameters:

isock A descriptor referencing the socket. 

connection_time Time in epoch.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_waitReady (int isock)

Wait the message "Ready" from a socket. 

Parameters:

isock A descriptor referencing the socket.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

int nmxp_sendDataRequest (int isock, int32_t key, int32_t start_time,
int32_t end_time)

Sends the message "DataRequest" on a socket. 

Parameters:

isock A descriptor referencing the socket. 

key Channel key for which data are requested. 

start_time Start time of the interval for which data are requested.
Epoch time. 

end_time End time of the interval for which data are requested. Epoch
time.

Return values:

SOCKET_OK on success 

SOCKET_ERROR on error 

 HYPERLINK "http://%5Cl%20%22AAAAAAAAAO%22" NMXP_CHAN_LIST *
nmxp_getAvailableChannelList (char * hostname, int portnum,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAX%22" NMXP_DATATYPE  datatype)

Get the list of available channels from a server. 

Parameters:

hostname host name 

portnum port number 

datatype Type of data contained in the channel.

Returns:

Channel list. It will need to be freed.

Warning:

Returned value will need to be freed. 

 HYPERLINK "http://%5Cl%20%22AAAAAAAAAY%22" NMXP_META_CHAN_LIST *
nmxp_getMetaChannelList (char * hostname, int portnum,  HYPERLINK
"http://%5Cl%20%22AAAAAAAAAX%22" NMXP_DATATYPE  datatype, int
flag_request_channelinfo)

Get the list of the start and end time for the available data for each
channel. 

Parameters:

hostname host name 

portnum port number 

datatype Type of data contained in the channel. 

flag_request_channelinfo Request information about Network.

Returns:

Channel list. It will need to be freed.

Warning:

Returned value will need to be freed. 

int nmxp_raw_stream_seq_no_compare (const void * a, const void * b)

Base function for qsort() in order to sort an array of pointers to
pointers to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS . 

Parameters:

a pointer to a pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  

b pointer to a pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  

void nmxp_raw_stream_init ( HYPERLINK "http://%5Cl%20%22AAAAAAAAAD%22"
NMXP_RAW_STREAM_DATA  * raw_stream_buffer, int32_t
max_tollerable_latency)

Allocate and initialize fields inside a  HYPERLINK
"http://%5Cl%20%22AAAAAAAABD%22" NMXP_RAW_STREAM_DATA  structure. 

Parameters:

raw_stream_buffer pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  struct to initialize 

max_tollerable_latency max tollerable latency in seconds. 

void nmxp_raw_stream_free ( HYPERLINK "http://%5Cl%20%22AAAAAAAAAD%22"
NMXP_RAW_STREAM_DATA  * raw_stream_buffer)

Free fields inside a  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  structure. 

Parameters:

raw_stream_buffer pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  struct to initialize 

int nmxp_raw_stream_manage ( HYPERLINK "http://%5Cl%20%22AAAAAAAAAD%22"
NMXP_RAW_STREAM_DATA  * p,  HYPERLINK "http://%5Cl%20%22AAAAAAAAAQ%22"
NMXP_DATA_PROCESS  * a_pd, int(*p_func_pd[NMXP_MAX_FUNC_PD])( HYPERLINK
"http://%5Cl%20%22AAAAAAAAAQ%22" NMXP_DATA_PROCESS  *), int n_func_pd)

Execute a list of functions on an chronological ordered array of 
HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22" NMXP_DATA_PROCESS 
structures. 

Parameters:

p pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  

a_pd pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABB%22"
NMXP_DATA_PROCESS  struct to insert into the array 

p_func_pd array of functions to execute on a single item  HYPERLINK
"http://%5Cl%20%22AAAAAAAABB%22" NMXP_DATA_PROCESS  

n_func_pd number of functions into the array p_func_pd 

int nmxp_raw_stream_manage_flush( HYPERLINK
"http://%5Cl%20%22AAAAAAAAAD%22" NMXP_RAW_STREAM_DATA  * p,
int(*p_func_pd[NMXP_MAX_FUNC_PD])( HYPERLINK
"http://%5Cl%20%22AAAAAAAAAQ%22" NMXP_DATA_PROCESS  *), int n_func_pd)

Execute a list of functions on remaining  HYPERLINK
"http://%5Cl%20%22AAAAAAAABB%22" NMXP_DATA_PROCESS  structures. 

Parameters:

p pointer to  HYPERLINK "http://%5Cl%20%22AAAAAAAABD%22"
NMXP_RAW_STREAM_DATA  

p_func_pd array of functions to execute on a single item  HYPERLINK
"http://%5Cl%20%22AAAAAAAABB%22" NMXP_DATA_PROCESS  

n_func_pd number of functions into the array p_func_pd 





Degne di particolare attenzione sono le funzioni che si occupano della
gestione del buffer dei pacchetti nelle connessioni di tipo Raw Stream,
cioi dei pacchetti compressi e con valore di Short-term-complete uguale
a -1. Per un canale sismico la funzione nmxp_raw_stream_manage() si
occupa di riordinare cronologicamente le strutture NMXP_DATA_PROCESS che
ad ogni chiamata le vengono passate, successivamente di eseguire sulle
stesse le n_func_pd funzioni i cui puntatori sono contenuti nell'array
p_func_pd. Nel caso in cui rilevi una discontinuita temporale del dato,
la funzione accoda in un buffer la struttura corrente inducendo cosm una
latenza sul flusso dei dati per quel canale. L'attesa dei pacchetti
mancanti termina quando il tempo massimo di latenza tollerabile,
impostato al momento dell'inizializzazione per mezzo della funzione
nmxp_raw_stream_init(), viene superato. In quest'ultimo caso la funzione
forzera l'esecuzione delle funzioni sulla prima struttura disponibile
causando quindi un gap sul flusso dei dati.

Uso delle APIs per sviluppare una nuova applicazione

Per sviluppare una propria applicazione in C che faccia uso della
libreria libnmxp vengono di seguito illustrati i sorgenti 1 e 2 che
possono essere utilizzati come base per l'implementazione dei protocolli
Data Access Protocol 1.0 e Private Data Stream 1.4. Su tali strutture di
codice C i basato anche nmxptool descritto successivamente.

Possiamo notare come risulti relativamente semplice sviluppare una
propria applicazione anche nel caso in cui si vogliano stabilire
connessioni di tipo Raw Stream. Infatti lo sviluppatore non dovra far
altro che utilizzare la struttura base del sorgente 2, eseguire le
opportune personalizzazioni, e dichiarare una funzione con prototipo

int ( *process_data_function ) ( NMXP_DATA_PROCESS *)

il cui puntatore dovra poi essere aggiunto nell'array da passare come
parametro alla funzione nmxp_raw_stream_manage().

Prima di poter richiamare la funzione nmxp_raw_stream_manage() bisogna
inizializzare per ogni canale, tramite la funzione
nmxp_raw_stream_init(), una struttura dati di tipo NMXP_RAW_STREAM_DATA
e il valore della massima latenza tollerabile.

Al termine del programma, o comunque al termine della connessione, sara
necessario liberare la memoria allocata dalla struttura
NMXP_RAW_STREAM_DATA per mezzo della funzione nmxp_raw_stream_free().
Opzionalmente, prima di questa funzione put essere richiamata
nmxp_raw_manage_stream_flush() che esegue le funzioni sui pacchetti
rimanenti indipendentemente dalla continuita del dato.

Sorgente 1. Struttura base in C che implementa D.A.P. versione 1.0
utilizzando le APIs di libnmxp.

/* ************************************************************** */

/* Start subscription protocol "DATA ACCESS PROTOCOL" version 1.0 */

/* ************************************************************** */

/* DAP Step 1: Open a socket */

if( (naqssock =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#44f981ae9125ff482b93e74a9df45c0c" nmxp_openSocket
(params.hostname, params.portnumberdap)) ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#4e3388111ddab1454d6bd987f1f17435" NMXP_SOCKET_ERROR )
{

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error opening socket!\n");

  return 1;

}

/* DAP Step 2: Read connection time */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#5242ad29c198813884300244dd10179e" nmxp_readConnectionTime
(naqssock, &connection_time) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error reading connection time from server!\n");

  return 1;

}

/* DAP Step 3: Send a ConnectRequest */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#b9ca7e70152dcbddd0f90fafcf764c98" nmxp_sendConnectRequest
(naqssock, params.datas_username, params.datas_password,
connection_time) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error sending connect request!\n");

  return 1;

}

/* DAP Step 4: Wait for a Ready message */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#e05f693ef0012617e25735f412c1f590" nmxp_waitReady (naqssock)
!=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (1, 0,
"Error waiting Ready message!\n");

  return 1;

}

while(exitdapcondition) {

  /* Start loop for sending requests */

  while(request_SOCKET_OK ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK   &&
 i_chan < channelList_subset->number) {

    /* DAP Step 5: Send Data Request */

    request_SOCKET_OK =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#6bf4cb425c1ae31248e19d2e053fbe90" nmxp_sendDataRequest
(naqssock, channelList_subset->channel[i_chan].key,

        (double) params.start_time, (double) params.end_time);

    if(request_SOCKET_OK ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

      /* DAP Step 6: Receive Data until receiving a Ready message */

      ret =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#c4f875c1f2e85f62e4c2521adc897479" nmxp_receiveMessage
(naqssock, &type, &buffer, &length);

       HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__log_8h.html#8622591085f346ff9826b84a11ee2413" nmxp_log (0, 1, "ret
= %d, type = %d\n", ret, type);

      while(ret ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK   
&&    type !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#ac688b3df69e8cf6f2ac256ee5da658bdf9196bb257dcc4c91847
7edc05bd6cb" NMXP_MSG_READY ) {

        /* Process a packet and return value in NMXP_DATA_PROCESS
structure */

        pd =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#8893b6eee3b7c72e999477d8c84da476"
nmxp_processCompressedData (buffer, length, channelList_subset,
CURRENT_NETWORK);

         HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#1a461f85840339c840b377a7f55991a0" nmxp_data_trim (pd,
params.start_time, params.end_time, 0);

        /* Log contents of last packet */

         HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#700d4b5ad54544d0546ffbc0d2aede35" nmxp_data_log (pd);

        if(pd->buffer) {

          free(pd->buffer);

          pd->buffer = NULL;

        }

        /* Receive Data */

        ret =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#c4f875c1f2e85f62e4c2521adc897479" nmxp_receiveMessage
(naqssock, &type, &buffer, &length);

      }

    }

    i_chan++;

  }

  /* DAP Step 7: Repeat steps 5 and 6 for each data request */

} /* END while(exitdapcondition) */

/* DAP Step 8: Send a Terminate message (optional) */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#13d94c3a1d78e315c72d3739331551f9"
nmxp_sendTerminateSubscription (naqssock,  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#2982ac3a4037ee612e56720295987f6df8cb753861ebf3a83e491
cd3d7cd5d69" NMXP_SHUTDOWN_NORMAL , "Bye!");

/* DAP Step 9: Close the socket */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#20009090764c1a6c6d3416275d0dcc89" nmxp_closeSocket
(naqssock);

/* ************************************************************ */

/* End subscription protocol "DATA ACCESS PROTOCOL" version 1.0 */

/* ************************************************************ */

Sorgente 2. Struttura base in C che implementa P.D.S. versione 1.4
utilizzando le APIs di libnmxp.

int n_func_pd = 0;

int (*p_func_pd[ HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#d01d7b80bf5ea8cf7cf6cb6d42d4a19f" NMXP_MAX_FUNC_PD ]) (
HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
struct_n_m_x_p___d_a_t_a___p_r_o_c_e_s_s.html" NMXP_DATA_PROCESS  *);

if(params.stc == -1) {

  if(params.flag_logdata) {

    p_func_pd[n_func_pd++] = nmxptool_print_seq_no;

  }

  /* Write Mini-SEED record */

  if(params.flag_writeseed) {

    p_func_pd[n_func_pd++] = nmxptool_write_miniseed;

  }

  /* Send data to SeedLink Server */

  if(params.flag_slink) {

    p_func_pd[n_func_pd++] = nmxptool_send_raw_depoch;

  }

}

/* ************************************************************* */

/* Start subscription protocol "PRIVATE DATA STREAM" version 1.4 */

/* ************************************************************* */

/* PDS Step 1: Open a socket */

if((naqssock =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#44f981ae9125ff482b93e74a9df45c0c" nmxp_openSocket
(params.hostname, params.portnumberpds)) ==  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#4e3388111ddab1454d6bd987f1f17435" NMXP_SOCKET_ERROR )
{

  return 1;

}

/* PDS Step 2: Send a Connect */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#8e89c3bd6d36475147d8d14212fdde3f" nmxp_sendConnect
(naqssock) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

  printf("Error on sendConnect()\n");  return 1;

}

/* PDS Step 3: Receive ChannelList */

if( HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#404bcdf536d593b187010ae8626234eb" nmxp_receiveChannelList
(naqssock, &channelList) !=  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#d0fb7eddd779d8a0e761bf877d866b56" NMXP_SOCKET_OK ) {

  printf("Error on receiveChannelList()\n");  return 1;

}

/* Get a subset of channel from arguments */

channelList_subset =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__chan_8h.html#cd8162e1d1e3a2d07c303567054d5d3d" nmxp_chan_subset
(channelList,  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__chan_8h.html#336bfce71e4b108b0cd469e0e2ddfcf7675e6d98f34fb0ed6a79a
34e49e3d2a2" NMXP_DATA_TIMESERIES , params.channels);

/* PDS Step 4: Send a Request Pending (optional) */

/* PDS Step 5: Send AddChannels */

/* Request Data */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#d56c1e95b99326395adc087ff6437ea0"
nmxp_sendAddTimeSeriesChannel (naqssock, channelList_subset, params.stc,
params.rate,

    (params.flag_buffered)?  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#a01c4a7e4cf68fb71d3c840db57388be8ac1f26351ac3fbe45666febe0c
325d5" NMXP_BUFFER_YES  :  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#a01c4a7e4cf68fb71d3c840db57388be6d79bfe520bb2e4f0278faead3b
97cb5" NMXP_BUFFER_NO );

/* PDS Step 6: Repeat until finished: receive and handle packets */

while(exitpdscondition) {

  /* Process Compressed or Decompressed Data */

  pd =  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#c364754b99340141d9dca8eb70352d98" nmxp_receiveData
(naqssock, channelList_subset, CURRENT_NETWORK);

  /* Log contents of last packet */

   HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#700d4b5ad54544d0546ffbc0d2aede35" nmxp_data_log (pd);

  /* Manage Raw Stream */

  if(params.stc == -1) {

      HYPERLINK "dddd"  nmxp_raw_stream_manage (&(raw_stream_buffer),
pd, p_func_pd, n_func_pd);

  }

  if(pd->buffer) {

    free(pd->buffer);  pd->buffer = NULL;

  }

}

/* PDS Step 7: Send Terminate Subscription */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp_8h.html#13d94c3a1d78e315c72d3739331551f9"
nmxp_sendTerminateSubscription (naqssock,  HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__data_8h.html#2982ac3a4037ee612e56720295987f6df8cb753861ebf3a83e491
cd3d7cd5d69" NMXP_SHUTDOWN_NORMAL , "Good Bye!");

/* PDS Step 8: Close the socket */

 HYPERLINK
"file:///Users/mtheo/Desktop/cvswork/mednet/mtheo/soft/libnmxp/doc/html/
nmxp__base_8h.html#20009090764c1a6c6d3416275d0dcc89" nmxp_closeSocket
(naqssock);

/* *********************************************************** */

/* End subscription protocol "PRIVATE DATA STREAM" version 1.4 */

/* *********************************************************** */

Il programma nmxptool

Al fine di capire cosa nxmptool permette di fare, lanciamo inizialmente
il comando che stampa a video terminale l'help delle opzioni del
comando:

kyuzo:~ mtheo$ nmxptool -h

nmxptool 0.22.0, Nanometrics tool based on libnmxp-0.22.0

        (Data Access Protocol 1.0, Private Data Stream 1.4)

Usage: nmxptool -H hostname --listchannels [...]

             Receive list of available channels on the host

       nmxptool -H hostname -C channellist -s DATE -e DATE [...]

             Receive data from hostname by DAP

       nmxptool -H hostname -C channellist [...]

             Receive data from hostname by PDS

Arguments:

  -H, --hostname=HOST     Nanometrics hostname.

  -C, --channels=LIST     Channel list STA1.HH?,STA2.??Z,...

Other arguments:

  -P, --portpds=PORT      NaqsServer port number (default 28000).

  -D, --portdap=PORT      DataServer port number (default 28002).

  -N, --network=NET       Declare Network code for all stations (default
'XX').

  -L, --location=LOC      Location code for writing file.

  -v, --verbose           Be verbose.

  -g, --logdata           Print info about data.

  -l, --listchannels      Output list of channel available on
NaqsServer.

  -i, --channelinfo       Output list of channel available on NaqsServer
and channelinfo.

  -m, --writeseed         Pack received data in Mini-SEED records and
write to a file.

  -w, --writefile         Dump received data to a file.

  -k, --slink=plug_name   Send received data to SeedLink like as
plug-in.

                          plug_name is set by SeisComP daemon.

                          THIS OPTION MUST BE THE LAST WITHOUT plug_name
IN seedlink.ini!

  -V, --version           Print tool version.

  -h, --help              Print this help.

DAP Arguments:

  -s, --start_time=DATE   Start time in date format.

  -e, --end_time=DATE     End time in date format.

                          DATE can be in formats:

                              <date>,<time> | <date>

                          where:

                              <date> = yyyy/mm/dd | yyy.jjj

                              <time> = hh:mm:ss | hh:mm

  -d, --delay=SECs        Receive continuosly data with delay
[60..86400].

  -u, --username=USER     DataServer username.

  -p, --password=PASS     DataServer password.

PDS arguments:

  -S, --stc=SECs          Short-term-completion (default -1).

                          -1 is for Raw Stream, no short-term
completion.

                           0 chronological order without waiting for
missing data.

                          [0..300] wait a period for the gap to be
filled by retransmitted packets.

                          Raw Stream is usable only with --rate=-1.

  -R, --rate=Hz           Receive data with specified sample rate
(default -1).

                          -1 is for original sample rate and compressed
data.

                           0 is for original sample rate and
decompressed data.

                          >0 is for specified sample rate and
decompressed data.

  -b, --buffered          Request also recent packets into the past.

  -M, --maxlatency=SECs   Max tolerable latency (default 600) [60..600].

                          Usable only with Raw Stream --stc=-1.

Matteo Quintiliani - Istituto Nazionale di Geofisica e Vulcanologia -
Italy

Mail bug reports and suggestions to <quintiliani@ingv.it>.



Da tale output deduciamo che un parametro sempre necessario i il nome o
l'IP del server al quale richiedere i dati. Il programma, in funzione
dei parametri passati, determina automaticamente se effettuare una
connessione al NaqsServer (porta 28000) oppure al DataServer (porta
28002). Se le porte dei servers non sono quelle di default i necessario
utilizzare le opzioni -P e -D. Un primo utilizzo di nmxptool per esempio
potrebbe essere quello di impiegarlo per reperire la lista dei canali
disponibili sul server e dei tempo di inizio e fine dei dati per ogni
canale. Cit si ottiene per mezzo del comando:

kyuzo:~ mtheo$ nmxptool -H hostname -l

Una parte di un possibile output:

...

1255538946 USI.HHE.IV      (2007.233,10:39:21.0000  - 
2007.243,09:59:44.0000)

1255538945 USI.HHN.IV      (2007.233,16:20:53.0000  - 
2007.243,09:59:45.0000)

1255538944 USI.HHZ.IV      (2007.233,22:26:08.0000  - 
2007.243,09:59:31.0000)

1238565122 VAGA.HHE.IV     (2007.225,07:10:14.0000  - 
2007.243,09:59:19.0000)

1238565121 VAGA.HHN.IV     (2007.225,08:35:24.0000  - 
2007.243,09:59:29.0000)

1238565120 VAGA.HHZ.IV     (2007.225,00:03:14.0000  - 
2007.243,09:59:29.0000)

...



Per ogni canale disponibile viene visualizzato:

l'indice numerico Nanometrics del canale, denominato key channel

il nome del canale nella forma Station.Channel.Network

data e ora di inizio dei dati disponibili

data e ora di fine dei dati disponibili

Successivamente potremmo richiedere al DataServer i dati appartenenti ad
un certo intervallo di tempo e di un insieme di canali, il comando
allora dovra contenere le opzioni -s, -e, -C,  quindi ad esempio:

kyuzo:~ mtheo$ nmxptool -H hostname -s 2007.242,00:00 -e
2007/08/30,00:00:05 \

                                                      -C
USI.???,VAGA.HHZ -g

Osserviamo che la data put essere scritta seguendo tali regole:

DATA,ORA oppure solamente DATA

dove:

DATA put essere espressa nei seguenti formati:

     aaaa/mm/gg

     aaa.jjj

jjj i il giorno giuliano dell'anno

ORA put essere espressa nei seguenti formati:

    hh:mm:ss

    hh:mm

Se si specifica solo DATA allora l'ora verra

automaticamente impostata a 00:00



Notiamo inoltre che la lista dei canali put contenere il carattere
speciale ? che ha il significato di ``qualsiasi carattere''. Alla riga
di comando abbiamo aggiunto anche l'opzione -g che visualizza
informazioni su ogni pacchetto ricevuto. Ecco un output possibile:

XX.USI.HHE 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.8699) lat
130115.1s [1, 48353370] (0)   87pts (-1128, -1128, 1742, 3226, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:00.8699 - 2007.242,00:00:01.9899) lat
130114.0s [1, 48353371] (0)  112pts (3226, 3226, 2423, 2688, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:01.9900 - 2007.242,00:00:03.1099) lat
130112.9s [1, 48353372] (0)  112pts (2688, 2688, -548, -686, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:03.1099 - 2007.242,00:00:04.2500) lat
130111.8s [1, 48353373] (0)  114pts (-686, -686, -857, -74, 1) 276

XX.USI.HHE 100Hz (2007.242,00:00:04.2500 - 2007.242,00:00:05.0000) lat
130111.0s [1, 48353374] (0)   75pts (-74, -74, 1290, 1338, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.2500) lat
130116.8s [1, 49688091] (0)   25pts (301, 301, 11, -143, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:00.2500 - 2007.242,00:00:01.3699) lat
130115.6s [1, 49688092] (0)  112pts (-143, -143, 926, 1534, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:01.3699 - 2007.242,00:00:02.5099) lat
130114.5s [1, 49688093] (0)  114pts (1534, 1534, -220, -17, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:02.5099 - 2007.242,00:00:03.6299) lat
130113.4s [1, 49688094] (0)  112pts (-17, -17, -866, -837, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:03.6300 - 2007.242,00:00:04.7900) lat
130112.2s [1, 49688095] (0)  116pts (-837, -837, -716, -527, 1) 276

XX.USI.HHN 100Hz (2007.242,00:00:04.7899 - 2007.242,00:00:05.0000) lat
130112.0s [1, 49688096] (0)   21pts (-527, -527, 999, 790, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.4400) lat
130116.6s [1, 50549101] (0)   44pts (-5470, -5470, -4031, -4326, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:00.4400 - 2007.242,00:00:01.5599) lat
130115.4s [1, 50549102] (0)  112pts (-4326, -4326, -6154, -6408, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:01.5599 - 2007.242,00:00:02.6799) lat
130114.3s [1, 50549103] (0)  112pts (-6408, -6408, -5355, -5326, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:02.6800 - 2007.242,00:00:03.7999) lat
130113.2s [1, 50549104] (0)  112pts (-5326, -5326, -4203, -4963, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:03.7999 - 2007.242,00:00:04.9199) lat
130112.1s [1, 50549105] (0)  112pts (-4963, -4963, -4980, -5066, 1) 276

XX.USI.HHZ 100Hz (2007.242,00:00:04.9200 - 2007.242,00:00:05.0000) lat
130112.0s [1, 50549106] (0)    8pts (-5066, -5066, -4823, -4804, 1) 276

XX.VAGA.HHZ 100Hz (2007.242,00:00:00.0000 - 2007.242,00:00:00.2999) lat
130116.7s [1, 7848381] (0)   30pts (-10567, -10567, -10553, -10550, 1)
276

XX.VAGA.HHZ 100Hz (2007.242,00:00:00.2999 - 2007.242,00:00:02.5399) lat
130114.5s [1, 7848382] (0)  224pts (-10550, -10550, -10456, -10458, 1)
276

XX.VAGA.HHZ 100Hz (2007.242,00:00:02.5399 - 2007.242,00:00:04.7799) lat
130112.2s [1, 7848383] (0)  224pts (-10458, -10458, -10363, -10362, 1)
276

XX.VAGA.HHZ 100Hz (2007.242,00:00:04.7799 - 2007.242,00:00:05.0000) lat
130112.0s [1, 7848384] (0)   22pts (-10362, -10362, -10331, -10337, 1)
276



Per ogni pacchetto ricevuto viene visualizzato:

il nome del canale nella forma Network.Station.Channel

la frequenza di campionamento

i tempi del primo e dell'ultimo campione

la latenza in secondi rispetto all'ora del client

il tipo del pacchetto Nanometrics e il suo numero di sequenza

il valore del numero di sequenza del pisch vecchio pacchetto disponibile

il numero di campioni presenti nel pacchetto

il valore x0 contenuto nell'intestazione (header) del pacchetto
Nanometrics

il primo e l'ultimo valore della serie di campioni

il valore xn, ovvero il valore calcolato che dovra avere x0 nel
pacchetto successivo

il flag che indica se x0 e xn sono significativi (0 significativo, -1
non significativo)

la lunghezza in bytes del pacchetto Nanometrics ricevuto

Nell'esempio precedente, non essendo stata definita la rete (network),
per default il programma l'ha impostata a `XX'. Nel caso avessimo voluto
salvare i dati in formato mini-SEED sarebbe stato sufficiente aggiungere
l'opzione -m e il programma avrebbe generato un file per ogni canale.
Inoltre, se il DataServer avesse richiesto l'autenticazione si sarebbero
dovute utilizzare le opzioni per la definizione del nome utente e della
password, ovvero -u e -p.

Per avere un flusso di dati continuo ma in differita con uno specifico
tempo stabilito i possibile utilizzare l'opzione -d. In questo modo si
ricevono quindi dati in flusso continuo dal DataServer tenendo fissa la
latenza al valore impostato. Ad esempio, per 1 ora (3600 secondi) di
differita ecco un possibile comando:

kyuzo:~ mtheo$ nmxptool -H hostname -d 3600 -C USI.???,VAGA.HHZ -g

Per ricevere dati in tempo reale, ovvero da un NaqsServer, i
sufficiente, in generale, non definire l'intervallo temporale. Quindi un
comando del tipo:

kyuzo:~ mtheo$ nmxptool -H hostname -C USI.??? -g -R 100

restituirebbe un output simile a questo di seguito:

XX.USI.HHN 100Hz (2007.243,12:22:48.0000 - 2007.243,12:22:49.0000) lat
9.0s [4, -1] (-1)  100pts (-1, 2080, 2488, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:48.0000 - 2007.243,12:22:49.0000) lat
9.0s [4, -1] (-1)  100pts (-1, 703, 2789, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:49.0000 - 2007.243,12:22:50.0000) lat
8.0s [4, -1] (-1)  100pts (-1, 2947, -1268, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:49.0000 - 2007.243,12:22:50.0000) lat
8.0s [4, -1] (-1)  100pts (-1, 1924, 204, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:49.0000 - 2007.243,12:22:50.0000) lat
8.0s [4, -1] (-1)  100pts (-1, 2490, -1004, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:50.0000 - 2007.243,12:22:51.0000) lat
7.0s [4, -1] (-1)  100pts (-1, -931, 1006, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:50.0000 - 2007.243,12:22:51.0000) lat
7.0s [4, -1] (-1)  100pts (-1, -1131, 1239, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:50.0000 - 2007.243,12:22:51.0000) lat
7.0s [4, -1] (-1)  100pts (-1, -103, -588, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:51.0000 - 2007.243,12:22:52.0000) lat
6.0s [4, -1] (-1)  100pts (-1, 951, 3495, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:51.0000 - 2007.243,12:22:52.0000) lat
6.0s [4, -1] (-1)  100pts (-1, 1318, 790, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:51.0000 - 2007.243,12:22:52.0000) lat
6.0s [4, -1] (-1)  100pts (-1, -467, 93, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:52.0000 - 2007.243,12:22:53.0000) lat
5.0s [4, -1] (-1)  100pts (-1, 365, 956, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:52.0000 - 2007.243,12:22:53.0000) lat
5.0s [4, -1] (-1)  100pts (-1, 3356, 2437, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:52.0000 - 2007.243,12:22:53.0000) lat
5.0s [4, -1] (-1)  100pts (-1, 1034, 1527, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:53.0000 - 2007.243,12:22:54.0000) lat
4.0s [4, -1] (-1)  100pts (-1, 951, 16, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:53.0000 - 2007.243,12:22:54.0000) lat
4.0s [4, -1] (-1)  100pts (-1, 2559, -319, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:53.0000 - 2007.243,12:22:54.0000) lat
4.0s [4, -1] (-1)  100pts (-1, 1472, 675, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:54.0000 - 2007.243,12:22:55.0000) lat
3.0s [4, -1] (-1)  100pts (-1, 255, -351, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:54.0000 - 2007.243,12:22:55.0000) lat
3.0s [4, -1] (-1)  100pts (-1, -668, 1457, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:54.0000 - 2007.243,12:22:55.0000) lat
3.0s [4, -1] (-1)  100pts (-1, 1101, 1541, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:55.0000 - 2007.243,12:22:56.0000) lat
2.0s [4, -1] (-1)  100pts (-1, -540, 1162, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:55.0000 - 2007.243,12:22:56.0000) lat
2.0s [4, -1] (-1)  100pts (-1, 1593, -488, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:55.0000 - 2007.243,12:22:56.0000) lat
2.0s [4, -1] (-1)  100pts (-1, 1608, 1355, -1, 0) 420

XX.USI.HHE 100Hz (2007.243,12:22:56.0000 - 2007.243,12:22:57.0000) lat
1.0s [4, -1] (-1)  100pts (-1, 1324, -1674, -1, 0) 420

XX.USI.HHN 100Hz (2007.243,12:22:56.0000 - 2007.243,12:22:57.0000) lat
2.0s [4, -1] (-1)  100pts (-1, -371, 2315, -1, 0) 420

XX.USI.HHZ 100Hz (2007.243,12:22:56.0000 - 2007.243,12:22:57.0000) lat
2.0s [4, -1] (-1)  100pts (-1, 1279, 967, -1, 0) 420



L'opzione -R i stata utilizzata per dichiarare che i pacchetti da
ricevere sarebbe stati scompattati dal server con una frequenza di
100Hz. Notiamo infatti che il pacchetto i di tipo 4, ovvero decompresso,
con una capacita fissa di un secondo e che x0 e xn non sono
significativi. Invece per i pacchetti compressi (pacchetto di tipo 1)
avremmo anche pouto specificare, tramite l'opzione -S, un valore fra 1 e
300 secondi dello Short-term-complete, oppure 0 per nessun
Short-term-complete,  oppure uguale -1 per ricevere i pacchetti in
modalita Raw Stream. 

Quest'ultimo caso rappresenta una delle funzionalita pisch importanti di
nmxptool poichy consente di ricevere i pacchetti in modo continuo in
tempo reale, in ordine cronologico, con minima latenza e minimo numero
di gaps.  Il programma  i in grado di gestire il buffering dei pacchetti
trasmessi e ritrasmessi, il loro riordinamento e l'esecuzione delle
operazione selezionate tramite le opzioni. Un'opzione collegata a questa
gestione i -M che serve a specificare la massima latenza tollerabile
nell'attesa di un pacchetto mancante. Di conseguenza da tale opzione
dipende la grandezza del buffer.

Quando si interagisce con il NaqsServer si put anche utilizzare
l'opzione -b, la quale permette di ricevere anche alcuni dati, in
quantita discrezionale del server, che precedono quelli dell'istante
attuale di richiesta.



Figura 3. Archiviazione dati sismici in tempo reale e completamento in
differita. Le due attivita si basano con modalita diverse su nmxptool.
Nel primo caso, nmxptool viene utilizzato come plug-in seedLink in
modalita Raw Stream, nel secondo i dati mancanti vengono richiesti da
nmxptool al DataServer e ricongiunti alla struttura di archiviazione SDS
di SeisComP.



Plug-in SeedLink

Con qualsiasi configurazione di opzioni descritte precedentemente,
nmxptool put essere lanciato come un plug-in per SeedLink per mezzo
dell'utilizzo dell'opzione -k. Questa opzione deve essere
necessariamente dichiarata per ultima. All'interno della distribuzione
sono inoltre disponibili i templates SeedLink necessari alla
configurazione del plug-in per mezzo del comando ``seiscomp config''. E'
comunque in corso la richiesta per inserire nmxptool fra i plug-ins
delle distribuzioni ufficiali di SeisComP.

Completezza del dato Nanometrics

La figura 3 illustra come nmxptool viene utilizzato all'interno
dell'INGV per archiviare i dati sismici delle stazioni che trasmettono
tramite i protocolli Nanometrics. Le forme d'onda vengono ricevute in
tempo reale in modalita Raw Stream al fine di minimizzare la latenza e
il numero di gaps. nmxptool viene configurato e lanciato all'interno del
sistema SeisComp come plug-in per SeedLink. La latenza indotta dal
programma e non, ad esempio quella causata dal mezzo trasmissivo, i
determinata solo nel caso in cui si rimanga in attesa di uno o pisch
pacchetti mancanti. Tale attesa termina nel momento in cui il buffer
risulti completamente pieno comportando quindi una perdita di dati
(gap).

Al fine di garantire completezza dei dati archiviati i stata sviluppata
una procedura dal nome ``Nanometrics Data Completness'' che basandosi
sulla versatilita di nmxptool recupera i dati mancanti con differita
impostata a qualche ora o il giorno successivo. In questo caso i gaps
risultanti non potranno pisch essere colmati poichy i dati richiesti non
risultano definitivamente pisch essere presenti sul lato dei servers
Nanometrics.

Conclusioni

Lo sviluppo e i test eseguiti in questi ultimi due mesi, hanno permesso
di realizzare una libreria nel suo complesso stabile ed efficiente.
Considerando congiuntamente libnmxp e nmxptool, anche il numero di
funzionalita implementate risulta essere molto soddisfacente. La pisch
importante fra tutte i sicuramente la gestione delle connessioni di tipo
Raw Stream, che riesce a garantire una bassa latenza e nel contempo un
numero minino di gaps. Grazie a questa caratteristica nmxptool apporta
finalmente un fondamentale contributo alla comunita degli utilizzatori
del sistema SeisComp per l'acquisizione da servers Nanometrics. Infatti
naqs_plugin, il plug-in precedentemente sviluppato a tale scopo, non
essendo in grado di gestire ne' i pacchetti compressi, ne' tantomeno
connessioni di tipo Raw Stream, non poteva garantire minimamente la
continuita del dato al verificarsi di una ritrasmissione dal lato
Nanometrics Server - Stazione Sismica (fig. 1).

Le tabelle 2 e 3 mostrano i reports sintetici dei dati archiviati per i
canali in test il 18 e il 19 settembre 2007. Giornalmente, per ogni
canale viene visualizzato:

Totale di pacchetti ritrasmessi: per una trasmissione di tipo
short-term-complete i dati contenuti in questi pacchetti sarebbero stati
persi e avrebbero causato dei gaps.

Massima latenza registrata: la massima latenza registrata durante il
giorno e indotta dall'attesa dei pacchetti mancanti. Per tale test la
latenza massima tollerabile i stata impostata a 600 secondi.

Numero di gaps ottenuti in tempo reale tramite l'acquisizione dei dati
per mezzo di nmxptool usato come plug-in SeedLink. Possiamo notare come
il numero di gaps ottenuti in tempo reale dipenda fortemente dall'attesa
dei pacchetti ritrasmessi.

Numero di gaps definitivi ottenuti recuperando i dati il giorno dopo dal
DataServer per mezzo di nmxptool lanciato in linea comando.

Percentuale dei pacchetti persi in tempo reale: il valore i il risultato
della seguente espressione: [ (Gaps Tempo Reale - Gaps Definitivi) /
Pacchetti Ritrasmessi ] * 100. Questo valore put essere interpretato
come espressione della bonta nella scelta del valore di massima latenza
tollerabile per quel dato canale. Su questo valore e secondariamente
sulla latenza massima sono state ordinate le due tabelle.

Al momento nmxptool viene utilizzato come plug-in SeedLink anche nei
seguenti istituti di ricerca ai quali va anche un riconoscimento per la
loro collaborazione in fase di test e debugging del software:

National Data Center, Israele. (Guy Tikochinsky)

Institute of Geodynamics, National Observatory of Athens, Grecia. (Nicos
Melis)

Possiamo quindi sintetizzare i risultati ottenuti rilevando che
l'utilizzo di nmxptool con connessioni in tempo reale al NaqsServer
(online) di tipo Raw Stream, garantisce un ottimo compromesso fra
continuita del dato e latenza indotta, mentre il suo utilizzo con
connessioni in differita al DataServer (offline) garantisce pienamente
la completezza del dato (fig. 3).

E' evidente inoltre che la versalita di nmxptool e il numero di
funzionalita offerte, sono un valido supporto a procedure che
necessitano di dati a richiesta, come ad esempio il calcolo della
magnitudo o del momento tensore dopo un evento sismico.

Per il futuro, l'autore intende manutenere libnmxp e nmxptool ed
ampliare le funzionalita della libreria anche per quanto riguarda la
gestione dei dati di tipo serial data, triggers, events e
state-of-health. Inoltre i in corso di sviluppo un'estensione delle
capacita di nmxptool al fine di poter essere eseguito come modulo del
sistema Earthworm, poichy anche l'attuale modulo naqs2ew presenta simili
problematiche di naqs_plugin con SeisComP.



Canale	Pacchetti Ritrasmessi	Latenza Massima (sec.)	Gaps

Tempo reale	Gaps

definitivi	Percentuale Persi

NOCI.HHZ

AMUR.HHZ

SALO.HHN

SALO.HHE

SALO.HHZ

NOCI.HHN

NOCI.HHE

MABI.HHZ

AMUR.HHN

AMUR.HHE

SCTE.HHZ

SCTE.HHN

SCTE.HHE

DOI.HHN

MABI.HHN

CARO.HHZ

CARO.HHN

DOI.HHZ

MABI.HHE

MSAG.HHZ

MRGE.HHZ

SGRT.HHZ

MRGE.HHE

MSAG.HHN

SGRT.HHN

MRGE.HHN

MSAG.HHE

SGRT.HHE

MONC.HHZ

TIR.HHN

MONC.HHN

TIR.HHZ

MONC.HHE

DOI.HHE

TIR.HHE

CARO.HHE

USI.HHZ

USI.HHN

USI.HHE

BOB.HHN

BOB.HHE

BOB.HHZ

MDI.HHZ

MDI.HHE

MDI.HHN	2

2

3

9

13

5

3

6

6

6

9

8

11

6

13

4

13

13

12

32

12

38

11

29

31

16

34

38

10

18

16

15

20

10

17

12

19

18

17

13

9

6

16

14

17	13.4

13.8

16.4

19.1

19.1

19.6

20.1

26.7

37.5

38.5

44.2

45.2

46.2

46.5

46.8

47.0

47.3

47.4

47.6

56.0

56.1

56.1

56.8

57.0

57.0

57.5

57.5

57.9

67.7

68.7

68.8

69.4

317.6

317.8

323.3

329.9

588.6

589.5

590.2

590.0

589.9

588.8

601.2

600.9

608.9	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

2

0

3

0

39

0

0

0

1

1

1

1

1

1

3

3

7	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

2

0

3

0

39

0

0

0

0

0

0

0

0

0

0

0

0	0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

5.2

5.5

5.8

7.6

11.1

16.6

18.7

21.4

41.1

Tabella 2. Report sintetico relativo ai dati archiviati dei canali in
test il 22 settembre 2007 tramite nmxptool e seedllink.





Canale	Pacchetti Ritrasmessi	Latenza Massima (sec.)	Gaps

Tempo reale	Gaps

definitivi	Percentuale Persi

AMUR.HHN

NOCI.HHZ

AMUR.HHZ

NOCI.HHN

AMUR.HHE

NOCI.HHE

DOI.HHZ

DOI.HHE

DOI.HHN

BOB.HHZ

BOB.HHE

BOB.HHN

SCTE.HHE

SCTE.HHZ

SCTE.HHN

MRGE.HHZ

CARO.HHE

MSAG.HHZ

MABI.HHE

MSAG.HHN

SALO.HHZ

CARO.HHN

MSAG.HHE

SALO.HHE

MABI.HHN

MABI.HHZ

CARO.HHZ

SGRT.HHN

MONC.HHZ

MONC.HHN

MRGE.HHE

MRGE.HHN

SGRT.HHE

SGRT.HHZ

TIR.HHE

USI.HHZ

USI.HHN

TIR.HHN

MONC.HHE

MDI.HHE

TIR.HHZ

SALO.HHN

USI.HHE

MDI.HHN

MDI.HHZ	2

2

2

3

2

1

11

4

5

12

12

9

1

4

6

13

11

29

11

21

17

7

20

12

14

6

12

23

11

15

14

11

31

21

18

23

13

12

16

10

9

14

20

6

4	14.4

15.3

16.3

17.0

18.3

19.2

24.9

26.5

28.0

31.2

31.4

31.9

36.0

36.2

39.1

45.6

46.0

46.4

46.5

46.5

46.9

47.0

47.0

47.2

47.3

47.6

47.8

56.3

56.4

56.9

57.4

57.4

57.5

57.5

58.8

59.2

67.7

324.8

325.1

326.2

326.3

327.3

600.5

603.6

607.1	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

3

2

0

0

0

0

0

0

0

0

34

0

0

0

1

3

2	0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

3

2

0

0

0

0

0

0

0

0

34

0

0

0

0

0

0	0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

0.0

5.0

50.0

50.0

Tabella 3. Report sintetico relativo ai dati archiviati dei canali in
test il 23 settembre 2007 tramite nmxptool e seedllink.



Ringraziamenti

Un particolare ringraziamento va a Salvatore Mazza per la fiducia che
sempre mi riserva. Sono inoltre riconoscente a Marco Olivieri per il suo
supporto nel controllo di qualita dei dati prodotti dalle mie
applicazioni.

Bibliografia e riferimenti web

Nanometrics, Inc., (1989-2002), Libra Satellite Seismograph System -
Training Course Notes.

SeisComP, The Seismological Communication Processor

http://www.gfz-potsdam.de/geofon/seiscomp/

Earthworm, Seismic network data acquisition and processing system

http://www.isti2.com/ew/

libmseed, 2.1.4, The Mini-SEED library

http://www.iris.edu/manuals/

Doxygen, Source code documentation generator tool

			http://www.stack.nl/~dimitri/doxygen/

GNU General Public License

			http://www.gnu.org/copyleft/gpl.html

 PAGE   

 PAGE   20 

